const fs = require('fs');
const path = require('path');

const root = path.resolve(__dirname, '..');
const templatesDir = path.join(root, 'docs', 'templates');
const outPath = path.join(root, 'src', 'services', 'webform', 'followup', 'bundledHtmlTemplates.ts');

const listTemplateFiles = () => {
  if (!fs.existsSync(templatesDir)) return [];
  return fs
    .readdirSync(templatesDir)
    .filter(f => f && typeof f === 'string' && f.toLowerCase().endsWith('.html'))
    .sort();
};

const files = listTemplateFiles();
const templates = {};

files.forEach(fileName => {
  const full = path.join(templatesDir, fileName);
  try {
    const raw = fs.readFileSync(full, 'utf8');
    templates[fileName] = raw;
  } catch (err) {
    console.error('[embed-html-templates] Failed reading', full, err && err.message ? err.message : err);
    process.exit(1);
  }
});

const banner = `// Auto-generated by scripts/embed-html-templates.js. Do not edit by hand.\n// Contains HTML templates embedded from /docs/templates for template ids like "bundle:<filename>".\n`;
const literal = JSON.stringify(templates, null, 2);

const output = `${banner}
export const BUNDLED_HTML_TEMPLATES: Record<string, string> = ${literal};

export const getBundledHtmlTemplateRaw = (key: string): string | null => {
  const k = (key || '').toString().trim();
  if (!k) return null;
  const raw = (BUNDLED_HTML_TEMPLATES as any)[k];
  const text = raw === undefined || raw === null ? '' : raw.toString();
  return text.trim() ? text : null;
};

export const parseBundledHtmlTemplateId = (templateId: string): string | null => {
  const t = (templateId || '').toString().trim();
  if (!t) return null;
  const m = /^bundle:\\s*(.+)$/i.exec(t);
  if (!m) return null;
  const key = (m[1] || '').toString().trim();
  return key || null;
};
`;

fs.mkdirSync(path.dirname(outPath), { recursive: true });
fs.writeFileSync(outPath, output, 'utf8');
console.info('[embed-html-templates] Embedded', files.length, 'template(s) into', outPath);


