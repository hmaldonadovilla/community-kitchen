// Auto-generated by scripts/embed-web-bundle.js. Do not edit by hand.
// Contains the bundled client code injected into the web form template.
export const WEB_FORM_BUNDLE: string = "\"use strict\";\n(() => {\n  // src/web/state/store.ts\n  var state = {\n    language: \"EN\",\n    values: {},\n    lineItems: {},\n    submitting: false,\n    recordMeta: {}\n  };\n  var listeners = /* @__PURE__ */ new Set();\n  function setState(next) {\n    const prev = state;\n    state = {\n      ...state,\n      ...next,\n      values: next.values ? { ...prev.values, ...next.values } : prev.values,\n      lineItems: next.lineItems ? { ...prev.lineItems, ...next.lineItems } : prev.lineItems,\n      recordMeta: next.recordMeta ? { ...prev.recordMeta || {}, ...next.recordMeta } : prev.recordMeta\n    };\n    listeners.forEach((l) => l(state, prev));\n    return state;\n  }\n\n  // src/web/i18n.ts\n  function resolveLocalizedString(value, language, fallback = \"\") {\n    if (!value && fallback) return fallback;\n    if (typeof value === \"string\") return value;\n    const key2 = (language || \"EN\").toString().toLowerCase();\n    return (value == null ? void 0 : value[key2]) || (value == null ? void 0 : value.en) || fallback;\n  }\n\n  // src/web/legacy/language.ts\n  function updateLanguageLabels(options) {\n    const { language, root = document } = options;\n    const langKey = (language || \"en\").toString().toLowerCase();\n    root.querySelectorAll(\"[data-en-label]\").forEach((el) => {\n      var _a, _b, _c, _d;\n      const label = ((_a = el.dataset) == null ? void 0 : _a[`${langKey}Label`]) || ((_b = el.dataset) == null ? void 0 : _b.enLabel) || \"\";\n      const optionLabel = (_c = el.querySelector) == null ? void 0 : _c.call(el, \".option-label\");\n      const textTarget = (_d = el.querySelector) == null ? void 0 : _d.call(el, \"[data-label-text]\");\n      if (optionLabel) {\n        optionLabel.textContent = label;\n        return;\n      }\n      if (textTarget) {\n        textTarget.textContent = label;\n        return;\n      }\n      const textNode = Array.from(el.childNodes || []).find((node) => node.nodeType === Node.TEXT_NODE);\n      if (textNode) {\n        textNode.textContent = label;\n      } else {\n        el.textContent = label;\n      }\n    });\n    root.querySelectorAll(\"option[data-en-label]\").forEach((opt) => {\n      var _a, _b;\n      const label = ((_a = opt.dataset) == null ? void 0 : _a[`${langKey}Label`]) || ((_b = opt.dataset) == null ? void 0 : _b.enLabel) || \"\";\n      opt.textContent = label;\n    });\n    root.querySelectorAll(\"button[data-default-label]\").forEach((btn) => {\n      var _a, _b;\n      const defaultLabel = ((_a = btn.dataset) == null ? void 0 : _a.defaultLabel) || \"+ Add line\";\n      let labels;\n      try {\n        labels = ((_b = btn.dataset) == null ? void 0 : _b.addLabels) ? JSON.parse(btn.dataset.addLabels) : void 0;\n      } catch (_) {\n        labels = void 0;\n      }\n      btn.textContent = resolveLocalizedString(labels, language, defaultLabel);\n    });\n  }\n\n  // src/web/rules/filter.ts\n  var normalize = (val) => {\n    if (val === null || val === void 0) return \"\";\n    return val.toString();\n  };\n  function computeAllowedOptions(filter, options, dependencyValues) {\n    if (!filter) return options.en || [];\n    const depValues = dependencyValues.map((v) => normalize(v));\n    const candidateKeys = [];\n    if (depValues.length > 1) candidateKeys.push(depValues.join(\"||\"));\n    depValues.filter(Boolean).forEach((v) => candidateKeys.push(v));\n    candidateKeys.push(\"*\");\n    const match = candidateKeys.reduce((acc, key2) => acc || filter.optionMap[key2], void 0);\n    if (match) return match;\n    return [];\n  }\n  function buildLocalizedOptions(options, allowed, language) {\n    const langKey = (language || \"en\").toString().toLowerCase();\n    const labels = options[langKey] || options.en || [];\n    const baseOpts = options.en || labels;\n    const allowedSet = allowed && allowed.length ? new Set(allowed) : null;\n    const values = allowedSet ? allowed : baseOpts;\n    const items = [];\n    values.forEach((value, idx) => {\n      var _a, _b, _c;\n      const base = baseOpts[idx] || value;\n      const labelIdx = baseOpts.indexOf(base);\n      const label = labelIdx >= 0 ? labels[labelIdx] || base : value;\n      items.push({\n        value: base,\n        label,\n        labels: {\n          en: ((_a = options.en) == null ? void 0 : _a[labelIdx]) || base,\n          fr: ((_b = options.fr) == null ? void 0 : _b[labelIdx]) || base,\n          nl: ((_c = options.nl) == null ? void 0 : _c[labelIdx]) || base\n        }\n      });\n    });\n    return items;\n  }\n\n  // src/web/legacy/dom.ts\n  function getValue(formEl, name) {\n    const els = formEl.querySelectorAll('[name=\"' + name + '\"]');\n    if (!els || els.length === 0) return \"\";\n    const el = els[0];\n    if (el instanceof HTMLSelectElement) return el.value;\n    if (el instanceof HTMLInputElement) {\n      if (el.type === \"checkbox\") {\n        return Array.from(els).filter((e) => e instanceof HTMLInputElement && e.checked).map((e) => e.value);\n      }\n      return el.value;\n    }\n    if (el instanceof HTMLTextAreaElement) return el.value;\n    return \"\";\n  }\n  function getRowValue(row, name) {\n    let els = row.querySelectorAll('[name=\"' + name + '\"]');\n    if (!els || els.length === 0) {\n      const wrapper = row.querySelector('[data-field-name=\"' + name + '\"]');\n      if (wrapper) {\n        els = wrapper.querySelectorAll(\"input\");\n      }\n    }\n    if (!els || els.length === 0) return \"\";\n    const el = els[0];\n    if (el instanceof HTMLSelectElement) return el.value;\n    if (el instanceof HTMLInputElement) {\n      if (el.type === \"checkbox\") {\n        return Array.from(els).filter((e) => e instanceof HTMLInputElement && e.checked).map((e) => e.value);\n      }\n      return el.value;\n    }\n    if (el instanceof HTMLTextAreaElement) return el.value;\n    return \"\";\n  }\n  function toggleFieldVisibility(holder, shouldHide) {\n    if (!holder) return;\n    if (shouldHide) {\n      holder.classList.add(\"is-hidden-field\");\n      const inputs = holder.querySelectorAll(\"input, select, textarea\");\n      inputs.forEach((input) => {\n        const data = input.dataset || {};\n        if (data.originalRequired === void 0) data.originalRequired = input.required ? \"true\" : \"false\";\n        input.required = false;\n        if (input instanceof HTMLInputElement && (input.type === \"checkbox\" || input.type === \"radio\")) {\n          input.checked = false;\n        } else {\n          try {\n            input.value = \"\";\n          } catch (_) {\n          }\n        }\n      });\n      const err = holder.querySelector(\".field-error\");\n      if (err) err.remove();\n    } else {\n      holder.classList.remove(\"is-hidden-field\");\n      const inputs = holder.querySelectorAll(\"input, select, textarea\");\n      inputs.forEach((input) => {\n        const data = input.dataset || {};\n        if (data.originalRequired === \"true\") input.required = true;\n      });\n    }\n  }\n  function findFieldElement(fieldId, formEl, scope) {\n    const ctx = scope || formEl;\n    return ctx.querySelector('[data-field-id=\"' + fieldId + '\"]') || ctx.querySelector('[name=\"' + fieldId + '\"]') || ctx.querySelector('[name$=\"__' + fieldId + '\"]') || ctx.querySelector('[data-field-name$=\"__' + fieldId + '\"]');\n  }\n  function isFieldHidden(fieldId, formEl, scope) {\n    const el = findFieldElement(fieldId, formEl, scope);\n    if (!el) return false;\n    const hiddenHolder = el.closest(\".is-hidden-field\");\n    return !!hiddenHolder;\n  }\n  function isEmptyLineItemRow(row) {\n    const inputs = Array.from(row.querySelectorAll(\"input, select, textarea\"));\n    for (const input of inputs) {\n      if (input instanceof HTMLInputElement) {\n        if (input.type === \"checkbox\" || input.type === \"radio\") {\n          if (input.checked) return false;\n        } else {\n          const val = (input.value || \"\").trim();\n          if (val !== \"\") return false;\n        }\n      } else if (input instanceof HTMLSelectElement) {\n        const val = (input.value || \"\").trim();\n        if (val !== \"\") return false;\n      } else if (input instanceof HTMLTextAreaElement) {\n        const val = (input.value || \"\").trim();\n        if (val !== \"\") return false;\n      }\n    }\n    return true;\n  }\n\n  // src/web/legacy/filters.ts\n  function applyFilterToElement(el, filter, options, language, dependencyValues) {\n    var _a;\n    const allowed = computeAllowedOptions(filter, options, dependencyValues);\n    const langKey = (language || \"en\").toString().toLowerCase();\n    if (el.tagName === \"SELECT\") {\n      const select = el;\n      const previous = select.value;\n      const currentSelections = previous ? [previous] : [];\n      const extras = currentSelections.filter((v) => v && !allowed.includes(v));\n      const allowedSet = new Set((allowed || []).map((v) => (v || \"\").toString().toLowerCase()));\n      const combined = [];\n      const seen = /* @__PURE__ */ new Set();\n      [...allowed, ...extras].forEach((v) => {\n        if (seen.has(v)) return;\n        seen.add(v);\n        combined.push(v);\n      });\n      select.innerHTML = \"\";\n      combined.forEach((base) => {\n        var _a2, _b, _c;\n        const optIdx = Array.isArray(options.en) ? options.en.indexOf(base) : -1;\n        const label = optIdx >= 0 ? (options[langKey] || [])[optIdx] || base : base;\n        const opt = document.createElement(\"option\");\n        opt.value = base;\n        opt.dataset.enLabel = optIdx >= 0 ? ((_a2 = options.en) == null ? void 0 : _a2[optIdx]) || base : base;\n        opt.dataset.frLabel = optIdx >= 0 ? ((_b = options.fr) == null ? void 0 : _b[optIdx]) || base : base;\n        opt.dataset.nlLabel = optIdx >= 0 ? ((_c = options.nl) == null ? void 0 : _c[optIdx]) || base : base;\n        opt.textContent = label;\n        if (previous && previous === base) opt.selected = true;\n        if (!allowedSet.size || allowedSet.has(base.toLowerCase()) || extras.includes(base)) {\n          select.appendChild(opt);\n        }\n      });\n    } else {\n      const wrapper = el.tagName === \"DIV\" ? el : el.parentElement;\n      if (!wrapper) return;\n      const inputs = wrapper.querySelectorAll('input[type=\"checkbox\"]');\n      const prevChecked = Array.from(inputs).filter((c) => c.checked).map((c) => c.value);\n      const extras = prevChecked.filter((v) => v && !allowed.includes(v));\n      const allowedSet = new Set((allowed || []).map((v) => (v || \"\").toString().toLowerCase()));\n      const combined = [];\n      const seen = /* @__PURE__ */ new Set();\n      [...allowed, ...extras].forEach((v) => {\n        if (seen.has(v)) return;\n        seen.add(v);\n        combined.push(v);\n      });\n      const nameAttr = ((_a = wrapper.dataset) == null ? void 0 : _a.fieldName) || wrapper.getAttribute(\"name\") || \"\";\n      wrapper.innerHTML = \"\";\n      combined.forEach((base, idx) => {\n        var _a2, _b, _c;\n        const localized = buildLocalizedOptions(options, [base], language)[0];\n        const id = nameAttr + \"_\" + idx + \"_\" + Math.random().toString(16).slice(2);\n        const l = document.createElement(\"label\");\n        l.className = \"inline\";\n        l.style.fontWeight = \"400\";\n        l.htmlFor = id;\n        l.dataset.enLabel = ((_a2 = localized == null ? void 0 : localized.labels) == null ? void 0 : _a2.en) || base;\n        l.dataset.frLabel = ((_b = localized == null ? void 0 : localized.labels) == null ? void 0 : _b.fr) || base;\n        l.dataset.nlLabel = ((_c = localized == null ? void 0 : localized.labels) == null ? void 0 : _c.nl) || base;\n        const cb = document.createElement(\"input\");\n        cb.type = \"checkbox\";\n        cb.name = nameAttr;\n        cb.id = id;\n        cb.value = base;\n        if (prevChecked.includes(base)) cb.checked = true;\n        const span = document.createElement(\"span\");\n        span.className = \"option-label\";\n        span.textContent = (localized == null ? void 0 : localized.label) || base;\n        l.appendChild(cb);\n        l.appendChild(span);\n        if (!allowedSet.size || allowedSet.has(base.toLowerCase()) || prevChecked.includes(base)) {\n          wrapper.appendChild(l);\n        }\n      });\n    }\n  }\n  function applyFilters(options) {\n    const { definition, language, formEl, scopeRow } = options;\n    const getDependencyValues = (dependsOn, row, linePrefix) => {\n      const ids = Array.isArray(dependsOn) ? dependsOn : [dependsOn];\n      return ids.map((id) => {\n        const prefixed = linePrefix ? `${linePrefix}__${id}` : id;\n        let val = row ? getRowValue(row, prefixed) : getValue(formEl, prefixed);\n        if ((val === \"\" || Array.isArray(val) && val.length === 0) && linePrefix) {\n          val = getValue(formEl, id);\n        }\n        if (Array.isArray(val)) return val.join(\"|\");\n        return val;\n      });\n    };\n    definition.questions.forEach((q) => {\n      if ((q.type === \"CHOICE\" || q.type === \"CHECKBOX\") && q.optionFilter) {\n        const target = q.type === \"CHECKBOX\" ? formEl.querySelector('[data-field-name=\"' + q.id + '\"]') || formEl.querySelector('[name=\"' + q.id + '\"]') : formEl.querySelector('[name=\"' + q.id + '\"]');\n        if (target) {\n          applyFilterToElement(target, q.optionFilter, q.options || { en: [], fr: [], nl: [] }, language, getDependencyValues(q.optionFilter.dependsOn));\n        }\n      }\n      if (q.type === \"LINE_ITEM_GROUP\") {\n        const container = formEl.querySelector('[data-line-item=\"' + q.id + '\"]');\n        if (!container) return;\n        const rows = scopeRow ? [scopeRow] : Array.from(container.querySelectorAll(\".line-item-row\"));\n        rows.forEach((row) => {\n          var _a;\n          (((_a = q.lineItemConfig) == null ? void 0 : _a.fields) || []).forEach((field) => {\n            if (!field.optionFilter) return;\n            const name = q.id + \"__\" + field.id;\n            const el = field.type === \"CHECKBOX\" ? row.querySelector('[data-field-name=\"' + name + '\"]') || row.querySelector('[name=\"' + name + '\"]') : row.querySelector('[name=\"' + name + '\"]');\n            if (el) {\n              applyFilterToElement(\n                el,\n                field.optionFilter,\n                { en: field.options || [], fr: field.optionsFr || [], nl: field.optionsNl || [] },\n                language,\n                getDependencyValues(field.optionFilter.dependsOn, row, q.id)\n              );\n            }\n          });\n        });\n      }\n    });\n  }\n\n  // src/web/rules/visibility.ts\n  function matchesWhen(value, when) {\n    if (!when) return true;\n    const values = Array.isArray(value) ? value : [value];\n    if (when.equals !== void 0) {\n      const expected = Array.isArray(when.equals) ? when.equals : [when.equals];\n      if (!values.some((v) => expected.includes(v))) return false;\n    }\n    const numericVals = values.map((v) => Number(v)).filter((v) => !isNaN(v));\n    if (when.greaterThan !== void 0) {\n      if (!numericVals.some((v) => v > Number(when.greaterThan))) return false;\n    }\n    if (when.lessThan !== void 0) {\n      if (!numericVals.some((v) => v < Number(when.lessThan))) return false;\n    }\n    return true;\n  }\n  function resolveVisibilityValue(condition, ctx, rowId, linePrefix) {\n    if (!condition) return \"\";\n    const scopedId = linePrefix ? `${linePrefix}__${condition.fieldId}` : condition.fieldId;\n    const direct = rowId && ctx.getLineValue ? ctx.getLineValue(rowId, scopedId) : ctx.getValue(scopedId);\n    if (direct !== void 0 && direct !== \"\" && direct !== null) return direct;\n    if (linePrefix) return ctx.getValue(condition.fieldId);\n    return direct;\n  }\n  function shouldHideField(visibility, ctx, options) {\n    if (!visibility) return false;\n    const rowId = options == null ? void 0 : options.rowId;\n    const linePrefix = options == null ? void 0 : options.linePrefix;\n    const showMatch = visibility.showWhen ? matchesWhen(resolveVisibilityValue(visibility.showWhen, ctx, rowId, linePrefix), visibility.showWhen) : true;\n    const hideMatch = visibility.hideWhen ? matchesWhen(resolveVisibilityValue(visibility.hideWhen, ctx, rowId, linePrefix), visibility.hideWhen) : false;\n    if (visibility.showWhen && !showMatch) return true;\n    if (visibility.hideWhen && hideMatch) return true;\n    return false;\n  }\n\n  // src/web/legacy/visibility.ts\n  function applyVisibility(options) {\n    const { definition, formEl } = options;\n    definition.questions.forEach((q) => {\n      if (q.visibility) {\n        const ctx = { getValue: (fieldId) => getValue(formEl, fieldId) };\n        const shouldHide = shouldHideField(q.visibility, ctx, { linePrefix: q.type === \"LINE_ITEM_GROUP\" ? q.id : void 0 });\n        const holder = formEl.querySelector('[data-qid=\"' + q.id + '\"]');\n        toggleFieldVisibility(holder, shouldHide);\n      }\n      if (q.type === \"LINE_ITEM_GROUP\") {\n        const container = formEl.querySelector('[data-line-item=\"' + q.id + '\"]');\n        if (!container) return;\n        const rows = Array.from(container.querySelectorAll(\".line-item-row\"));\n        rows.forEach((row) => {\n          var _a;\n          const rowCtx = {\n            getValue: (fieldId) => getValue(formEl, fieldId),\n            getLineValue: (_rowId, fieldId) => getRowValue(row, fieldId)\n          };\n          (((_a = q.lineItemConfig) == null ? void 0 : _a.fields) || []).forEach((field) => {\n            var _a2;\n            if (!field.visibility) return;\n            const hide = shouldHideField(field.visibility, rowCtx, { rowId: row.dataset.rowId, linePrefix: q.id });\n            const cell = row.querySelector('[data-field-id=\"' + field.id + '\"][data-group-id=\"' + q.id + '\"]') || ((_a2 = row.querySelector('[name=\"' + q.id + \"__\" + field.id + '\"]')) == null ? void 0 : _a2.closest(\"div\"));\n            toggleFieldVisibility(cell || row, hide);\n          });\n        });\n      }\n    });\n  }\n\n  // src/web/rules/validation.ts\n  var defaultRuleMessages = {\n    required: {\n      en: \"This field is required.\",\n      fr: \"Ce champ est obligatoire.\",\n      nl: \"Dit veld is verplicht.\"\n    },\n    allowed: {\n      en: \"Please use an allowed value.\",\n      fr: \"Veuillez utiliser une valeur autoris\\xE9e.\",\n      nl: \"Gebruik een toegestane waarde.\"\n    },\n    disallowed: {\n      en: \"This combination is not allowed.\",\n      fr: \"Cette combinaison n'est pas autoris\\xE9e.\",\n      nl: \"Deze combinatie is niet toegestaan.\"\n    }\n  };\n  var withLimitMessage = (prefix, limit) => ({\n    en: `${prefix} ${limit}.`,\n    fr: `${prefix} ${limit}.`,\n    nl: `${prefix} ${limit}.`\n  });\n  function checkRule(value, thenCfg, language, message) {\n    var _a, _b;\n    const values = Array.isArray(value) ? value : [value];\n    const customMessage = message ? resolveLocalizedString(message, language, \"\") : \"\";\n    if (thenCfg == null ? void 0 : thenCfg.required) {\n      const hasValue = values.some((v) => {\n        if (v === void 0 || v === null) return false;\n        if (typeof v === \"string\") return v.trim() !== \"\";\n        return true;\n      });\n      if (!hasValue) {\n        return customMessage || resolveLocalizedString(defaultRuleMessages.required, language, \"This field is required.\");\n      }\n    }\n    if ((thenCfg == null ? void 0 : thenCfg.min) !== void 0) {\n      const minVal = Number(thenCfg.min);\n      const numVals = values.map((v) => Number(v)).filter((v) => !isNaN(v));\n      if (numVals.some((v) => v < minVal)) {\n        return customMessage || resolveLocalizedString(withLimitMessage(\"Value must be >=\", thenCfg.min), language, \"Value must be >= \" + thenCfg.min + \".\");\n      }\n    }\n    if ((thenCfg == null ? void 0 : thenCfg.max) !== void 0) {\n      const maxVal = Number(thenCfg.max);\n      const numVals = values.map((v) => Number(v)).filter((v) => !isNaN(v));\n      if (numVals.some((v) => v > maxVal)) {\n        return customMessage || resolveLocalizedString(withLimitMessage(\"Value must be <=\", thenCfg.max), language, \"Value must be <= \" + thenCfg.max + \".\");\n      }\n    }\n    if (((_a = thenCfg == null ? void 0 : thenCfg.allowed) == null ? void 0 : _a.length) && !values.every((v) => {\n      var _a2;\n      return (_a2 = thenCfg.allowed) == null ? void 0 : _a2.includes(v);\n    })) {\n      return customMessage || resolveLocalizedString(defaultRuleMessages.allowed, language, \"Please use an allowed value.\");\n    }\n    if (((_b = thenCfg == null ? void 0 : thenCfg.disallowed) == null ? void 0 : _b.length) && values.some((v) => {\n      var _a2;\n      return (_a2 = thenCfg.disallowed) == null ? void 0 : _a2.includes(v);\n    })) {\n      return customMessage || resolveLocalizedString(defaultRuleMessages.disallowed, language, \"This combination is not allowed.\");\n    }\n    return \"\";\n  }\n  function validateRules(rules, ctx) {\n    const errors = [];\n    rules.forEach((rule) => {\n      const whenValue = ctx.getValue(rule.when.fieldId);\n      if (!matchesWhen(whenValue, rule.when)) return;\n      if (ctx.isHidden && ctx.isHidden(rule.then.fieldId)) return;\n      const targetVal = ctx.getValue(rule.then.fieldId);\n      const msg = checkRule(targetVal, rule.then, ctx.language, rule.message);\n      if (msg) {\n        errors.push({\n          fieldId: rule.then.fieldId,\n          message: msg,\n          scope: \"main\"\n        });\n      }\n    });\n    return errors;\n  }\n\n  // src/web/legacy/validation.ts\n  function getLineItemRowCount(groupId, formEl) {\n    const container = formEl.querySelector('[data-line-item=\"' + groupId + '\"]');\n    if (!container) return 0;\n    return Array.from(container.querySelectorAll(\".line-item-row\")).filter((row) => {\n      return !row.classList.contains(\"is-hidden-field\") && !isEmptyLineItemRow(row);\n    }).length;\n  }\n  function fileInputMissing(name, formEl) {\n    const el = formEl.querySelector('input[type=\"file\"][name=\"' + name + '\"]');\n    if (!el) return false;\n    if (isFieldHidden(name, formEl)) return false;\n    return !(el.files && el.files.length > 0);\n  }\n  function validateFormWithBundle(definition, language, formEl) {\n    const errors = [];\n    const missingRequiredLineItem = definition.questions.find(\n      (q) => q.type === \"LINE_ITEM_GROUP\" && q.required && !isFieldHidden(q.id, formEl) && getLineItemRowCount(q.id, formEl) === 0\n    );\n    if (missingRequiredLineItem) {\n      errors.push({\n        fieldId: missingRequiredLineItem.id,\n        message: language === \"FR\" ? \"Ajoutez au moins une ligne.\" : language === \"NL\" ? \"Voeg minstens \\xE9\\xE9n regel toe.\" : \"Please add at least one line.\",\n        scope: \"main\"\n      });\n      return { errors };\n    }\n    definition.questions.filter((q) => q.type === \"FILE_UPLOAD\" && q.required).forEach((fq) => {\n      if (fileInputMissing(fq.id, formEl)) {\n        errors.push({\n          fieldId: fq.id,\n          message: language === \"FR\" ? \"Veuillez t\\xE9l\\xE9verser un fichier.\" : language === \"NL\" ? \"Upload een bestand.\" : \"Please upload a file.\",\n          scope: \"main\"\n        });\n      }\n    });\n    if (errors.length) return { errors };\n    const mainRules = definition.questions.flatMap((q) => (q.validationRules || []).map((rule) => ({ rule, scope: \"main\" })));\n    const ctx = {\n      language,\n      getValue: (fieldId) => getValue(formEl, fieldId),\n      isHidden: (fieldId) => isFieldHidden(fieldId, formEl)\n    };\n    errors.push(...validateRules(mainRules.map((r) => r.rule), ctx));\n    if (errors.length) return { errors };\n    definition.questions.filter((q) => q.type === \"LINE_ITEM_GROUP\").forEach((group) => {\n      var _a;\n      const container = formEl.querySelector('[data-line-item=\"' + group.id + '\"]');\n      if (!container) return;\n      const rows = Array.from(container.querySelectorAll(\".line-item-row\")).filter(\n        (r) => !r.classList.contains(\"is-hidden-field\") && !isEmptyLineItemRow(r)\n      );\n      (((_a = group.lineItemConfig) == null ? void 0 : _a.fields) || []).forEach((field) => {\n        (field.validationRules || []).forEach((rule) => {\n          rows.forEach((row) => {\n            const whenName = group.id + \"__\" + rule.when.fieldId;\n            const thenName = group.id + \"__\" + rule.then.fieldId;\n            let whenVal = getRowValue(row, whenName);\n            if (whenVal === \"\" || Array.isArray(whenVal) && whenVal.length === 0) {\n              whenVal = getValue(formEl, rule.when.fieldId);\n            }\n            if (!matchesWhen(whenVal, rule.when)) return;\n            if (isFieldHidden(rule.then.fieldId, formEl, row)) return;\n            const targetVal = getRowValue(row, thenName);\n            const msg = checkRule(targetVal, rule.then, language, rule.message);\n            if (msg) {\n              errors.push({\n                fieldId: rule.then.fieldId,\n                message: msg,\n                scope: \"line\",\n                rowId: row.dataset.rowId\n              });\n            }\n          });\n        });\n      });\n    });\n    if (errors.length && typeof console !== \"undefined\" && console.warn) {\n      console.warn(\"[validation] errors\", errors);\n    }\n    return { errors };\n  }\n  function resolveFieldElement(err, formEl) {\n    if (err.scope === \"line\" && err.rowId) {\n      const row = formEl.querySelector('[data-row-id=\"' + err.rowId + '\"]');\n      if (row) {\n        return findFieldElement(err.fieldId, row, row);\n      }\n    }\n    return findFieldElement(err.fieldId, formEl);\n  }\n\n  // src/web/legacy/payload.ts\n  function syncLineItemPayload(definition, formEl) {\n    definition.questions.forEach((q) => {\n      if (q.type !== \"LINE_ITEM_GROUP\") return;\n      const container = formEl.querySelector('[data-line-item=\"' + q.id + '\"]');\n      const hidden = formEl.querySelector('[name=\"' + q.id + '_json\"]');\n      if (!container || !hidden) return;\n      const rows = Array.from(container.querySelectorAll(\".line-item-row\")).filter(\n        (r) => !r.classList.contains(\"is-hidden-field\") && !isEmptyLineItemRow(r)\n      );\n      const data = rows.map((row) => {\n        var _a;\n        const result = {};\n        (((_a = q.lineItemConfig) == null ? void 0 : _a.fields) || []).forEach((field) => {\n          const name = q.id + \"__\" + field.id;\n          const inputs = row.querySelectorAll('[name=\"' + name + '\"]');\n          if (!inputs || inputs.length === 0) return;\n          if (inputs[0].type === \"checkbox\") {\n            const selected = Array.from(inputs).filter((i) => i.checked).map((i) => i.value);\n            result[field.id] = selected.join(\", \");\n          } else {\n            result[field.id] = inputs[0].value;\n          }\n        });\n        return result;\n      });\n      hidden.value = JSON.stringify(data);\n    });\n  }\n  function buildPayloadFromForm(formEl) {\n    const fd = new FormData(formEl);\n    const payload = {};\n    const fileReads = [];\n    const addValue = (key2, val) => {\n      if (payload[key2] === void 0) {\n        payload[key2] = val;\n      } else if (Array.isArray(payload[key2])) {\n        payload[key2].push(val);\n      } else {\n        payload[key2] = [payload[key2], val];\n      }\n    };\n    fd.forEach((val, key2) => {\n      if (val instanceof File) {\n        if (!val || !val.name && val.size === 0) return;\n        const reader = new FileReader();\n        const p = new Promise((resolve) => {\n          reader.onload = () => {\n            addValue(key2, {\n              name: val.name || \"upload\",\n              data: reader.result,\n              type: val.type || \"application/octet-stream\"\n            });\n            resolve();\n          };\n          reader.onerror = () => resolve();\n        });\n        reader.readAsDataURL(val);\n        fileReads.push(p);\n      } else {\n        addValue(key2, val);\n      }\n    });\n    return Promise.all(fileReads).then(() => payload);\n  }\n\n  // src/web/lineItems/index.ts\n  function isEmptyRow(rowValues) {\n    const entries = Object.values(rowValues);\n    return entries.every((val) => {\n      if (val === null || val === void 0) return true;\n      if (typeof val === \"string\") return val.trim() === \"\";\n      if (Array.isArray(val)) return val.length === 0;\n      return false;\n    });\n  }\n  function computeTotals(input, language) {\n    const { config, rows } = input;\n    if (!config.totals || !config.totals.length) return [];\n    return config.totals.map((totalCfg) => {\n      let total = 0;\n      if (totalCfg.type === \"count\") {\n        total = rows.filter((r) => !isEmptyRow(r.values)).length;\n      } else if (totalCfg.type === \"sum\") {\n        const fieldKey = totalCfg.fieldId;\n        if (fieldKey) {\n          rows.forEach((row) => {\n            const val = row.values[fieldKey];\n            const parsed = Array.isArray(val) ? Number(val[0]) : Number(val);\n            if (!isNaN(parsed)) total += parsed;\n          });\n        } else {\n          total = 0;\n        }\n      }\n      const label = resolveLocalizedString(\n        totalCfg.label,\n        language,\n        totalCfg.type === \"count\" ? \"Total\" : totalCfg.fieldId || \"Total\"\n      );\n      return {\n        key: totalCfg.fieldId || totalCfg.type,\n        label,\n        value: Number.isFinite(total) ? total : 0,\n        decimalPlaces: totalCfg.decimalPlaces\n      };\n    });\n  }\n\n  // src/web/data/dataSources.ts\n  var cache = /* @__PURE__ */ new Map();\n  var RUNNER_RETRY_DELAY = 150;\n  var RUNNER_MAX_ATTEMPTS = 20;\n  function key(id, lang) {\n    return `${id || \"default\"}::${(lang || \"EN\").toString().toUpperCase()}`;\n  }\n  function emitLog(level, message, payload) {\n    var _a, _b;\n    const localConsole = typeof console !== \"undefined\" ? console : void 0;\n    (_a = localConsole == null ? void 0 : localConsole[level]) == null ? void 0 : _a.call(localConsole, message, payload);\n    try {\n      if (typeof window !== \"undefined\" && window.parent && window.parent !== window) {\n        const parentConsole = window.parent.console;\n        (_b = parentConsole == null ? void 0 : parentConsole[level]) == null ? void 0 : _b.call(parentConsole, message, payload);\n      }\n    } catch (_) {\n    }\n  }\n  function isChoiceOrCheckbox(type) {\n    const normalized = (type || \"\").toString().toUpperCase();\n    return normalized === \"CHOICE\" || normalized === \"CHECKBOX\";\n  }\n  async function fetchDataSource(config, language) {\n    const cacheKey = key(config.id, language);\n    if (cache.has(cacheKey)) return cache.get(cacheKey);\n    return new Promise((resolve) => {\n      let attempts = 0;\n      const attempt = () => {\n        var _a, _b, _c;\n        const scriptRun = (_a = google == null ? void 0 : google.script) == null ? void 0 : _a.run;\n        if (!scriptRun) {\n          attempts += 1;\n          if (attempts === 1) {\n            emitLog(\"info\", \"[DataSource] google.script.run not ready, retrying\", { id: config.id });\n          }\n          if (attempts > RUNNER_MAX_ATTEMPTS) {\n            emitLog(\"error\", \"[DataSource] google.script.run never became ready\", { id: config.id });\n            resolve(null);\n            return;\n          }\n          setTimeout(attempt, RUNNER_RETRY_DELAY);\n          return;\n        }\n        try {\n          (_c = (_b = scriptRun.withSuccessHandler((res) => {\n            emitLog(\"info\", \"[DataSource] fetchDataSource success\", {\n              id: config.id,\n              itemCount: Array.isArray(res == null ? void 0 : res.items) ? res.items.length : Array.isArray(res) ? res.length : 0\n            });\n            cache.set(cacheKey, res);\n            resolve(res);\n          }).withFailureHandler((err) => {\n            emitLog(\"error\", \"[DataSource] fetchDataSource failed\", { id: config.id, err });\n            resolve(null);\n          })).fetchDataSource) == null ? void 0 : _c.call(_b, config, language, config.projection, config.limit, void 0);\n        } catch (_) {\n          emitLog(\"error\", \"[DataSource] fetchDataSource threw synchronously\", { id: config.id });\n          resolve(null);\n        }\n      };\n      attempt();\n    });\n  }\n  async function resolveQuestionOptionsFromSource(question, language) {\n    if (!question.dataSource || !isChoiceOrCheckbox(question.type)) {\n      return null;\n    }\n    const res = await fetchDataSource(question.dataSource, language);\n    if (!res) return null;\n    const items = Array.isArray(res.items) ? res.items : Array.isArray(res) ? res : [];\n    if (!items.length) return null;\n    const mapping = question.dataSource.mapping || {};\n    const valueKey = mapping.value || mapping.id;\n    if (typeof items[0] === \"object\" && !Array.isArray(items[0])) {\n      const keys = Object.keys(items[0]);\n      if (!keys.length) return null;\n      const resolvedKey = valueKey || keys[0];\n      return items.map((row) => row[resolvedKey]).filter(Boolean).map((v) => v.toString());\n    }\n    return items.map((v) => v != null ? v.toString() : \"\").filter(Boolean);\n  }\n\n  // src/web/effects/selectionEffects.ts\n  function applies(effect, value) {\n    if (!effect.triggerValues || effect.triggerValues.length === 0) return true;\n    const vals = Array.isArray(value) ? value : value ? [value] : [];\n    return vals.some((v) => effect.triggerValues.includes(v));\n  }\n  function isDebug() {\n    try {\n      return typeof window !== \"undefined\" && Boolean(window.__WEB_FORM_DEBUG__);\n    } catch (_) {\n      return false;\n    }\n  }\n  function handleSelectionEffects(definition, question, value, language, ctx, options) {\n    var _a;\n    if (!(question == null ? void 0 : question.selectionEffects) || !question.selectionEffects.length) return;\n    const debug = isDebug();\n    const contextId = (options == null ? void 0 : options.contextId) || \"__global__\";\n    const normalizedSelections = normalizeSelectionValues(value);\n    const diffPreview = previewSelectionDiff(question, contextId, normalizedSelections, options == null ? void 0 : options.forceContextReset);\n    if (debug && typeof console !== \"undefined\") {\n      console.info(\"[SelectionEffects] evaluating\", {\n        questionId: question.id,\n        value,\n        effectCount: question.selectionEffects.length,\n        contextId,\n        rowId: (_a = options == null ? void 0 : options.lineItem) == null ? void 0 : _a.rowId,\n        currentSelections: diffPreview.currentSelections,\n        newlySelected: diffPreview.newlySelected,\n        removedSelections: diffPreview.removedSelections\n      });\n    }\n    question.selectionEffects.forEach((effect) => {\n      const match = applies(effect, value);\n      if (debug && typeof console !== \"undefined\") {\n        console.info(\"[SelectionEffects] effect check\", {\n          questionId: question.id,\n          effectType: effect.type,\n          groupId: effect.groupId,\n          match,\n          triggerValues: effect.triggerValues\n        });\n      }\n      if (!match) return;\n      if (effect.type === \"addLineItems\") {\n        ctx.addLineItemRow(effect.groupId, effect.preset);\n        if (debug && typeof console !== \"undefined\") {\n          console.info(\"[SelectionEffects] addLineItems dispatched\", {\n            groupId: effect.groupId,\n            preset: effect.preset\n          });\n        }\n        return;\n      }\n      if (effect.type === \"addLineItemsFromDataSource\") {\n        populateLineItemsFromDataSource({\n          effect,\n          definition,\n          question,\n          language,\n          ctx,\n          debug,\n          contextId,\n          normalizedSelections,\n          diff: diffPreview,\n          lineItem: options == null ? void 0 : options.lineItem\n        });\n      }\n    });\n  }\n  var selectionEffectState = /* @__PURE__ */ new Map();\n  var ROW_CONTEXT_PREFIX = \"$row.\";\n  var ROW_CONTEXT_KEY = \"__ckRowContext\";\n  function getStateKey(question) {\n    return question.id;\n  }\n  function getOrCreateCache(question) {\n    const key2 = getStateKey(question);\n    if (!selectionEffectState.has(key2)) {\n      selectionEffectState.set(key2, { contexts: /* @__PURE__ */ new Map(), token: 0 });\n    }\n    return selectionEffectState.get(key2);\n  }\n  function getContextMap(cache2, contextId, create = false) {\n    const key2 = contextId || \"__global__\";\n    if (!cache2.contexts.has(key2)) {\n      if (!create) return void 0;\n      cache2.contexts.set(key2, /* @__PURE__ */ new Map());\n    }\n    return cache2.contexts.get(key2);\n  }\n  function normalizeString(val) {\n    if (val === void 0 || val === null) return \"\";\n    return val.toString().trim();\n  }\n  function normalizeSelectionValues(value) {\n    if (!value) return [];\n    const entries = Array.isArray(value) ? value : [value];\n    const normalized = entries.map(normalizeString).filter(Boolean);\n    return Array.from(new Set(normalized));\n  }\n  function previewSelectionDiff(question, contextId, normalizedSelections, forceContextReset) {\n    const cache2 = getOrCreateCache(question);\n    const contextMap = getContextMap(cache2, contextId, true);\n    const previousSelections = Array.from(contextMap.keys());\n    if (forceContextReset) {\n      contextMap.clear();\n    }\n    const removedSelections = forceContextReset ? previousSelections : previousSelections.filter((sel) => !normalizedSelections.includes(sel));\n    const newlySelected = normalizedSelections.filter((sel) => !contextMap.has(sel));\n    return {\n      newlySelected,\n      removedSelections,\n      currentSelections: normalizedSelections\n    };\n  }\n  function resolveLookupField(effect, question, sampleRow) {\n    var _a;\n    if (effect.lookupField) return effect.lookupField;\n    const mapping = (_a = question.dataSource) == null ? void 0 : _a.mapping;\n    if (mapping == null ? void 0 : mapping.value) return mapping.value;\n    if (mapping == null ? void 0 : mapping.id) return mapping.id;\n    if (sampleRow && typeof sampleRow === \"object\") {\n      const keys = Object.keys(sampleRow);\n      if (keys.length) return keys[0];\n    }\n    return void 0;\n  }\n  function coerceItemsCollection(payload) {\n    if (!payload) return [];\n    if (Array.isArray(payload)) return payload;\n    if (typeof payload === \"string\") {\n      const trimmed = payload.trim();\n      if (!trimmed) return [];\n      try {\n        const parsed = JSON.parse(trimmed);\n        if (Array.isArray(parsed)) return parsed;\n        if (parsed && typeof parsed === \"object\") return [parsed];\n      } catch (_) {\n        const parts = trimmed.split(/\\r?\\n/).map((part) => part.trim()).filter(Boolean);\n        if (parts.length) {\n          return parts.map((value) => ({ value }));\n        }\n      }\n      return [];\n    }\n    if (typeof payload === \"object\") return [payload];\n    return [];\n  }\n  function getValueFromPath(source, path) {\n    if (!source || !path) return void 0;\n    const segments = path.split(\".\").map((seg) => seg.trim()).filter(Boolean);\n    if (!segments.length) return void 0;\n    let current = source;\n    for (const segment of segments) {\n      if (current === void 0 || current === null || typeof current !== \"object\") return void 0;\n      current = current[segment];\n    }\n    return current;\n  }\n  function getValueFromSourceRow(source, path) {\n    if (!source || !path) return void 0;\n    const direct = getValueFromPath(source, path);\n    if (direct !== void 0) return direct;\n    if (typeof source !== \"object\" || !source) return void 0;\n    const normalized = path.toLowerCase();\n    const fallbackKey = Object.keys(source).find((key2) => key2.toLowerCase() === normalized);\n    if (fallbackKey) return source[fallbackKey];\n    return void 0;\n  }\n  function getRowContext(entry) {\n    if (!entry || typeof entry !== \"object\") return void 0;\n    return entry[ROW_CONTEXT_KEY];\n  }\n  function resolveRowContextValue(entry, sourcePath) {\n    if (!sourcePath || !sourcePath.startsWith(ROW_CONTEXT_PREFIX)) return void 0;\n    const rowField = sourcePath.slice(ROW_CONTEXT_PREFIX.length).trim();\n    if (!rowField) return void 0;\n    const ctx = getRowContext(entry);\n    if (!ctx) return void 0;\n    return ctx[rowField];\n  }\n  function resolveMappingValue(entry, sourcePath) {\n    if (!sourcePath) return void 0;\n    if (sourcePath.startsWith(ROW_CONTEXT_PREFIX)) {\n      return resolveRowContextValue(entry, sourcePath);\n    }\n    return getValueFromPath(entry, sourcePath);\n  }\n  function attachRowContext(entries, rowValues) {\n    if (!rowValues) return entries;\n    const snapshot = { ...rowValues };\n    return entries.map((entry) => ({\n      ...entry,\n      [ROW_CONTEXT_KEY]: snapshot\n    }));\n  }\n  function buildPreset(entry, effect, lineFieldIds) {\n    const mapping = effect.lineItemMapping || {};\n    const targetFields = Object.keys(mapping).length ? Object.keys(mapping) : lineFieldIds;\n    const preset = {};\n    targetFields.forEach((fieldId) => {\n      const sourcePath = mapping[fieldId] || fieldId;\n      const rawValue = resolveMappingValue(entry, sourcePath);\n      if (rawValue === void 0 || rawValue === null || rawValue === \"\") return;\n      preset[fieldId] = typeof rawValue === \"number\" ? rawValue : rawValue.toString();\n    });\n    return preset;\n  }\n  function setValueAtPath(target, path, value) {\n    if (!target || !path) return;\n    const segments = path.split(\".\").map((seg) => seg.trim()).filter(Boolean);\n    if (!segments.length) return;\n    let current = target;\n    for (let i = 0; i < segments.length - 1; i += 1) {\n      const segment = segments[i];\n      if (current[segment] === void 0 || current[segment] === null || typeof current[segment] !== \"object\") {\n        current[segment] = {};\n      }\n      current = current[segment];\n    }\n    current[segments[segments.length - 1]] = value;\n  }\n  function parseNumericValue(value) {\n    if (Array.isArray(value)) {\n      return Number(value[0]);\n    }\n    return Number(value);\n  }\n  function determineScaleFactor(effect, lineItemContext, sourceRow) {\n    if (!effect.rowMultiplierFieldId) return 1;\n    const rowValues = (lineItemContext == null ? void 0 : lineItemContext.rowValues) || {};\n    const desiredRaw = rowValues[effect.rowMultiplierFieldId];\n    const desiredValue = parseNumericValue(desiredRaw);\n    if (!Number.isFinite(desiredValue)) return 1;\n    if (!effect.dataSourceMultiplierField) return desiredValue;\n    const baselineRaw = getValueFromSourceRow(sourceRow, effect.dataSourceMultiplierField);\n    const baseline = Number(baselineRaw);\n    if (!Number.isFinite(baseline) || baseline === 0) {\n      if (isDebug() && typeof console !== \"undefined\") {\n        console.info(\"[SelectionEffects] scale baseline missing\", {\n          groupId: effect.groupId,\n          rowId: lineItemContext == null ? void 0 : lineItemContext.rowId,\n          fieldId: effect.dataSourceMultiplierField,\n          baseline: baselineRaw\n        });\n      }\n      return desiredValue;\n    }\n    const factor = desiredValue / baseline;\n    if (isDebug() && typeof console !== \"undefined\") {\n      console.info(\"[SelectionEffects] scale factor computed\", {\n        groupId: effect.groupId,\n        rowId: lineItemContext == null ? void 0 : lineItemContext.rowId,\n        multiplierField: effect.rowMultiplierFieldId,\n        sourceField: effect.dataSourceMultiplierField,\n        desired: desiredValue,\n        baseline,\n        factor\n      });\n    }\n    return factor;\n  }\n  function resolveNumericTargets(effect, group) {\n    var _a, _b;\n    if (effect.scaleNumericFields && effect.scaleNumericFields.length) {\n      return effect.scaleNumericFields;\n    }\n    if (effect.aggregateNumericFields && effect.aggregateNumericFields.length) {\n      return effect.aggregateNumericFields;\n    }\n    const numericFields = ((_b = (_a = group.lineItemConfig) == null ? void 0 : _a.fields) == null ? void 0 : _b.filter((field) => field.type === \"NUMBER\").map((field) => field.id)) || [];\n    return numericFields;\n  }\n  function applyScale(entries, effect, lineItemContext, sourceRow, group) {\n    const scaleFactor = determineScaleFactor(effect, lineItemContext, sourceRow);\n    const targets = resolveNumericTargets(effect, group);\n    const mapping = effect.lineItemMapping || {};\n    return entries.map((entry) => {\n      const clone = { ...entry };\n      if (isFinite(scaleFactor) && scaleFactor !== 1 && targets.length) {\n        targets.forEach((fieldId) => {\n          const sourcePath = mapping[fieldId] || fieldId;\n          const currentValue = Number(getValueFromPath(clone, sourcePath));\n          if (!Number.isFinite(currentValue)) return;\n          const scaledRaw = currentValue * scaleFactor;\n          if (!Number.isFinite(scaledRaw)) return;\n          const scaledValue = Number(scaledRaw.toFixed(2));\n          setValueAtPath(clone, sourcePath, scaledValue);\n        });\n      }\n      return clone;\n    });\n  }\n  function populateLineItemsFromDataSource({\n    effect,\n    definition,\n    question,\n    language,\n    ctx,\n    debug,\n    contextId,\n    normalizedSelections,\n    diff,\n    lineItem\n  }) {\n    const sourceConfig = effect.dataSource || question.dataSource;\n    if (!sourceConfig) {\n      if (debug && typeof console !== \"undefined\") {\n        console.warn(\"[SelectionEffects] data-driven effect missing dataSource config\", {\n          questionId: question.id,\n          effect\n        });\n      }\n      return;\n    }\n    const group = definition.questions.find((q) => q.id === effect.groupId);\n    if (!group || group.type !== \"LINE_ITEM_GROUP\" || !group.lineItemConfig) {\n      if (debug && typeof console !== \"undefined\") {\n        console.warn(\"[SelectionEffects] target group missing or misconfigured\", {\n          effect,\n          questionId: question.id\n        });\n      }\n      return;\n    }\n    const cache2 = getOrCreateCache(question);\n    const contextMap = getContextMap(cache2, contextId, true);\n    diff.removedSelections.forEach((sel) => contextMap.delete(sel));\n    if (!normalizedSelections.length) {\n      contextMap.clear();\n      if (debug && typeof console !== \"undefined\") {\n        console.info(\"[SelectionEffects] context cleared (no selections)\", { questionId: question.id, contextId });\n      }\n      renderAggregatedRows({\n        effect,\n        definition,\n        group,\n        cache: cache2,\n        ctx,\n        debug\n      });\n      return;\n    }\n    const missingSelections = normalizedSelections.filter((sel) => !contextMap.has(sel));\n    if (!missingSelections.length) {\n      renderAggregatedRows({\n        effect,\n        definition,\n        group,\n        cache: cache2,\n        ctx,\n        debug\n      });\n      return;\n    }\n    const stateToken = ++cache2.token;\n    fetchDataSource(sourceConfig, language).then((res) => {\n      var _a;\n      if (stateToken !== cache2.token) {\n        return;\n      }\n      const rows = Array.isArray(res == null ? void 0 : res.items) ? res.items : Array.isArray(res) ? res : [];\n      if (!rows.length) {\n        if (debug && typeof console !== \"undefined\") {\n          console.warn(\"[SelectionEffects] data-driven effect: no rows returned\", {\n            questionId: question.id,\n            sourceId: sourceConfig.id\n          });\n        }\n        contextMap.clear();\n        renderAggregatedRows({\n          effect,\n          definition,\n          group,\n          cache: cache2,\n          ctx,\n          debug\n        });\n        return;\n      }\n      const sampleRow = rows[0];\n      const lookupField = resolveLookupField(effect, question, sampleRow);\n      if (!lookupField) {\n        if (debug && typeof console !== \"undefined\") {\n          console.warn(\"[SelectionEffects] unable to resolve lookupField\", {\n            questionId: question.id,\n            effect\n          });\n        }\n        return;\n      }\n      const lineFieldIds = (((_a = group.lineItemConfig) == null ? void 0 : _a.fields) || []).map((field) => field.id);\n      missingSelections.forEach((selectedValue) => {\n        const normalizedTarget = selectedValue.toLowerCase();\n        const row = rows.find((candidate) => {\n          const candidateValue = normalizeString(candidate == null ? void 0 : candidate[lookupField]).toLowerCase();\n          return candidateValue === normalizedTarget;\n        });\n        if (!row) {\n          if (debug && typeof console !== \"undefined\") {\n            console.warn(\"[SelectionEffects] no matching row for selection\", {\n              questionId: question.id,\n              selectedValue,\n              lookupField\n            });\n          }\n          contextMap.delete(selectedValue);\n          return;\n        }\n        const payload = effect.dataField ? row[effect.dataField] : row;\n        const entries = coerceItemsCollection(payload);\n        if (!entries.length) {\n          if (debug && typeof console !== \"undefined\") {\n            console.warn(\"[SelectionEffects] data-driven effect produced no entries\", {\n              questionId: question.id,\n              selectedValue,\n              dataField: effect.dataField\n            });\n          }\n          contextMap.delete(selectedValue);\n          return;\n        }\n        const scaledEntries = applyScale(entries, effect, lineItem, row, group);\n        const enrichedEntries = attachRowContext(scaledEntries, lineItem == null ? void 0 : lineItem.rowValues);\n        contextMap.set(selectedValue, {\n          value: selectedValue,\n          entries: enrichedEntries\n        });\n      });\n      renderAggregatedRows({\n        effect,\n        definition,\n        group,\n        cache: cache2,\n        ctx,\n        debug\n      });\n    }).catch((err) => {\n      if (debug && typeof console !== \"undefined\") {\n        console.error(\"[SelectionEffects] data-driven effect failed\", err);\n      }\n    });\n  }\n  function renderAggregatedRows({\n    effect,\n    group,\n    cache: cache2,\n    ctx,\n    debug\n  }) {\n    const entriesForAllSelections = [];\n    cache2.contexts.forEach((selectionMap) => {\n      selectionMap.forEach((entry) => {\n        if (entry.entries && entry.entries.length) {\n          entriesForAllSelections.push(...entry.entries);\n        }\n      });\n    });\n    if (!entriesForAllSelections.length) {\n      if (effect.clearGroupBeforeAdd !== false && typeof ctx.clearLineItems === \"function\") {\n        ctx.clearLineItems(effect.groupId);\n      }\n      if (debug && typeof console !== \"undefined\") {\n        console.warn(\"[SelectionEffects] data-driven effect produced no entries after filtering\", {\n          questionId: group.id\n        });\n      }\n      return;\n    }\n    if (effect.clearGroupBeforeAdd !== false && typeof ctx.clearLineItems === \"function\") {\n      ctx.clearLineItems(effect.groupId);\n    }\n    const aggregatedPresets = aggregateEntries(entriesForAllSelections, effect, group);\n    aggregatedPresets.forEach((preset) => {\n      ctx.addLineItemRow(effect.groupId, preset);\n      if (debug && typeof console !== \"undefined\") {\n        console.info(\"[SelectionEffects] addLineItemsFromDataSource dispatched\", {\n          groupId: effect.groupId,\n          preset\n        });\n      }\n    });\n  }\n  function aggregateEntries(entries, effect, group) {\n    var _a;\n    const fields = ((_a = group.lineItemConfig) == null ? void 0 : _a.fields) || [];\n    const numericFieldIds = (effect.aggregateNumericFields && effect.aggregateNumericFields.length ? effect.aggregateNumericFields : fields.filter((field) => field.type === \"NUMBER\").map((field) => field.id)).map((id) => id.toString());\n    const implicitNonNumeric = fields.map((field) => field.id).filter((fieldId) => !numericFieldIds.includes(fieldId));\n    const nonNumericFieldIds = (effect.aggregateBy && effect.aggregateBy.length ? effect.aggregateBy : implicitNonNumeric).map((id) => id.toString());\n    const lineFieldIds = fields.map((field) => field.id);\n    const buckets = /* @__PURE__ */ new Map();\n    entries.forEach((entry) => {\n      const preset = buildPreset(entry, effect, lineFieldIds);\n      const key2 = buildAggregationKey(preset, nonNumericFieldIds);\n      if (!buckets.has(key2)) {\n        buckets.set(key2, { ...preset });\n        return;\n      }\n      const target = buckets.get(key2);\n      numericFieldIds.forEach((fieldId) => {\n        var _a2, _b;\n        const current = Number((_a2 = target[fieldId]) != null ? _a2 : 0);\n        const incoming = Number((_b = preset[fieldId]) != null ? _b : 0);\n        const nextValue = (isNaN(current) ? 0 : current) + (isNaN(incoming) ? 0 : incoming);\n        target[fieldId] = nextValue;\n      });\n    });\n    return Array.from(buckets.values()).map((preset) => {\n      numericFieldIds.forEach((id) => {\n        if (preset[id] !== void 0 && preset[id] !== null) {\n          const asNumber = Number(preset[id]);\n          if (Number.isFinite(asNumber)) {\n            const rounded = Number(asNumber.toFixed(2));\n            preset[id] = rounded % 1 === 0 ? rounded.toString() : rounded.toFixed(2);\n          }\n        }\n      });\n      return preset;\n    });\n  }\n  function buildAggregationKey(preset, nonNumericFieldIds) {\n    if (!nonNumericFieldIds.length) {\n      return \"__all_numeric__\";\n    }\n    return nonNumericFieldIds.map((id) => {\n      var _a;\n      return `${id}::${(_a = preset[id]) != null ? _a : \"\"}`;\n    }).join(\"||\");\n  }\n\n  // src/web/legacy/dataSources.ts\n  function buildOptionEl(value, labels, langKey) {\n    const opt = document.createElement(\"option\");\n    opt.value = value;\n    opt.dataset.enLabel = labels.en || value;\n    opt.dataset.frLabel = labels.fr || value;\n    opt.dataset.nlLabel = labels.nl || value;\n    const localized = labels[langKey] || labels.en || value;\n    opt.textContent = localized;\n    return opt;\n  }\n  function writeOptionsToSelect(select, options, labelsMap) {\n    select.innerHTML = \"\";\n    const emptyOpt = document.createElement(\"option\");\n    emptyOpt.value = \"\";\n    emptyOpt.textContent = \"\";\n    select.appendChild(emptyOpt);\n    const langKey = (labelsMap.__lang || \"en\").toString().toLowerCase();\n    options.forEach((value, idx) => {\n      var _a, _b, _c;\n      const labels = {\n        en: ((_a = labelsMap.en) == null ? void 0 : _a[idx]) || value,\n        fr: ((_b = labelsMap.fr) == null ? void 0 : _b[idx]) || value,\n        nl: ((_c = labelsMap.nl) == null ? void 0 : _c[idx]) || value\n      };\n      select.appendChild(buildOptionEl(value, labels, langKey));\n    });\n    select.dataset.originalOptions = JSON.stringify({ en: labelsMap.en || options, fr: labelsMap.fr || options, nl: labelsMap.nl || options });\n  }\n  function writeOptionsToCheckbox(wrapper, name, options, labelsMap) {\n    wrapper.innerHTML = \"\";\n    const langKey = (labelsMap.__lang || \"en\").toString().toLowerCase();\n    options.forEach((value, idx) => {\n      var _a, _b, _c;\n      const labels = {\n        en: ((_a = labelsMap.en) == null ? void 0 : _a[idx]) || value,\n        fr: ((_b = labelsMap.fr) == null ? void 0 : _b[idx]) || value,\n        nl: ((_c = labelsMap.nl) == null ? void 0 : _c[idx]) || value\n      };\n      const id = name + \"_\" + idx + \"_\" + Math.random().toString(16).slice(2);\n      const label = document.createElement(\"label\");\n      label.className = \"inline\";\n      label.style.fontWeight = \"400\";\n      label.htmlFor = id;\n      label.dataset.enLabel = labels.en || value;\n      label.dataset.frLabel = labels.fr || value;\n      label.dataset.nlLabel = labels.nl || value;\n      const cb = document.createElement(\"input\");\n      cb.type = \"checkbox\";\n      cb.name = name;\n      cb.id = id;\n      cb.value = value;\n      const span = document.createElement(\"span\");\n      span.className = \"option-label\";\n      span.textContent = labels[langKey] || labels.en || value;\n      label.appendChild(cb);\n      label.appendChild(span);\n      wrapper.appendChild(label);\n    });\n    wrapper.dataset.originalOptions = JSON.stringify({ en: labelsMap.en || options, fr: labelsMap.fr || options, nl: labelsMap.nl || options });\n  }\n  function emitLog2(level, message, payload) {\n    var _a, _b, _c;\n    const localConsole = typeof globalThis === \"object\" && \"console\" in globalThis ? globalThis.console : void 0;\n    (_a = localConsole == null ? void 0 : localConsole[level]) == null ? void 0 : _a.call(localConsole, message, payload);\n    try {\n      const currentWindow = typeof globalThis === \"object\" && \"window\" in globalThis ? globalThis : void 0;\n      const parentWindow = currentWindow == null ? void 0 : currentWindow.parent;\n      if (parentWindow && parentWindow === currentWindow) {\n        return;\n      }\n      if (parentWindow) {\n        const parentConsole = parentWindow.console;\n        (_b = parentConsole == null ? void 0 : parentConsole[level]) == null ? void 0 : _b.call(parentConsole, message, payload);\n      }\n    } catch (err) {\n      (_c = localConsole == null ? void 0 : localConsole.debug) == null ? void 0 : _c.call(localConsole, \"[DataSource] emitLog parent mirror failed\", err);\n    }\n  }\n  async function hydrateQuestionOptions(question, language, formEl) {\n    emitLog2(\"info\", \"[DataSource] hydrateQuestionOptions start\", { questionId: question.id, type: question.type });\n    const options = await resolveQuestionOptionsFromSource(question, language);\n    const resolvedOptions = options != null ? options : [];\n    if (resolvedOptions.length === 0) {\n      emitLog2(\"warn\", \"[DataSource] no options returned\", { questionId: question.id });\n      return;\n    }\n    question.options = {\n      en: resolvedOptions,\n      fr: resolvedOptions,\n      nl: resolvedOptions\n    };\n    const langKey = (language || \"en\").toString().toLowerCase();\n    const labelsMap = {\n      en: resolvedOptions,\n      fr: resolvedOptions,\n      nl: resolvedOptions,\n      __lang: langKey\n    };\n    if (question.type === \"CHOICE\") {\n      const select = formEl.querySelector('[name=\"' + question.id + '\"]');\n      if (select) {\n        const previousValue = select.value;\n        writeOptionsToSelect(select, resolvedOptions, labelsMap);\n        if (previousValue && Array.from(select.options).some((opt) => opt.value === previousValue)) {\n          select.value = previousValue;\n        }\n      }\n      emitLog2(\"info\", \"[DataSource] choice options written\", { questionId: question.id, count: resolvedOptions.length });\n    } else if (question.type === \"CHECKBOX\") {\n      const wrapper = formEl.querySelector('[data-field-name=\"' + question.id + '\"]') || formEl.querySelector('[name=\"' + question.id + '\"]');\n      if (wrapper) {\n        const prevSelections = Array.from(wrapper.querySelectorAll('input[type=\"checkbox\"]')).filter((cb) => cb.checked).map((cb) => cb.value);\n        writeOptionsToCheckbox(wrapper, question.id, resolvedOptions, labelsMap);\n        if (prevSelections.length) {\n          wrapper.querySelectorAll('input[type=\"checkbox\"]').forEach((cb) => {\n            if (prevSelections.includes(cb.value)) cb.checked = true;\n          });\n        }\n      }\n      emitLog2(\"info\", \"[DataSource] checkbox options written\", { questionId: question.id, count: resolvedOptions.length });\n    }\n  }\n  async function hydrateLineItemFieldOptions(group, field, language, formEl) {\n    emitLog2(\"info\", \"[DataSource] hydrateLineItemFieldOptions start\", { groupId: group.id, fieldId: field.id, type: field.type });\n    const options = await resolveQuestionOptionsFromSource(\n      {\n        id: `${group.id}__${field.id}`,\n        type: field.type,\n        dataSource: field.dataSource\n      },\n      language\n    );\n    const resolvedOptions = options != null ? options : [];\n    if (!resolvedOptions.length) {\n      emitLog2(\"warn\", \"[DataSource] no line item options returned\", { groupId: group.id, fieldId: field.id });\n      return;\n    }\n    field.options = resolvedOptions;\n    field.optionsFr = resolvedOptions;\n    field.optionsNl = resolvedOptions;\n    const container = formEl.querySelector('[data-line-item=\"' + group.id + '\"]');\n    if (!container) return;\n    const langKey = (language || \"en\").toString().toLowerCase();\n    const labelsMap = {\n      en: resolvedOptions,\n      fr: resolvedOptions,\n      nl: resolvedOptions,\n      __lang: langKey\n    };\n    if (field.type === \"CHOICE\") {\n      const selects = container.querySelectorAll('select[name=\"' + group.id + \"__\" + field.id + '\"]');\n      selects.forEach((select) => {\n        const previousValue = select.value;\n        writeOptionsToSelect(select, resolvedOptions, labelsMap);\n        if (previousValue && Array.from(select.options).some((opt) => opt.value === previousValue)) {\n          select.value = previousValue;\n        }\n      });\n      emitLog2(\"info\", \"[DataSource] line item choice options written\", { groupId: group.id, fieldId: field.id, count: resolvedOptions.length });\n      return;\n    }\n    if (field.type === \"CHECKBOX\") {\n      const wrappers = container.querySelectorAll('[data-field-name=\"' + group.id + \"__\" + field.id + '\"]');\n      wrappers.forEach((wrapper) => {\n        const prevSelections = Array.from(wrapper.querySelectorAll('input[type=\"checkbox\"]')).filter((cb) => cb.checked).map((cb) => cb.value);\n        writeOptionsToCheckbox(wrapper, group.id + \"__\" + field.id, resolvedOptions, labelsMap);\n        if (prevSelections.length) {\n          wrapper.querySelectorAll('input[type=\"checkbox\"]').forEach((cb) => {\n            if (prevSelections.includes(cb.value)) cb.checked = true;\n          });\n        }\n      });\n      emitLog2(\"info\", \"[DataSource] line item checkbox options written\", { groupId: group.id, fieldId: field.id, count: resolvedOptions.length });\n    }\n  }\n  async function hydrateDataSources(definition, language, formEl) {\n    const tasks = [];\n    definition.questions.forEach((q) => {\n      var _a;\n      if (q.dataSource && (q.type === \"CHOICE\" || q.type === \"CHECKBOX\")) {\n        emitLog2(\"info\", \"[DataSource] scheduling hydration\", { questionId: q.id });\n        tasks.push(hydrateQuestionOptions(q, language, formEl));\n      }\n      if (q.type === \"LINE_ITEM_GROUP\") {\n        (((_a = q.lineItemConfig) == null ? void 0 : _a.fields) || []).forEach((field) => {\n          if (!field.dataSource || field.type !== \"CHOICE\" && field.type !== \"CHECKBOX\") return;\n          emitLog2(\"info\", \"[DataSource] scheduling line item hydration\", { groupId: q.id, fieldId: field.id });\n          tasks.push(hydrateLineItemFieldOptions(q, field, language, formEl));\n        });\n      }\n    });\n    await Promise.all(tasks);\n  }\n\n  // src/web/legacy/lineItems.ts\n  function addLineItemRowFromBundle(group, formEl, presetValues = {}) {\n    var _a;\n    if (group.type !== \"LINE_ITEM_GROUP\") return;\n    const container = formEl.querySelector('[data-line-item=\"' + group.id + '\"]');\n    if (!container) return;\n    const rowsWrapper = container.querySelector(\".line-item-rows\") || container;\n    const row = document.createElement(\"div\");\n    row.className = \"line-item-row\";\n    row.dataset.rowId = group.id + \"_\" + Math.random().toString(16).slice(2);\n    row.dataset.groupId = group.id;\n    (((_a = group.lineItemConfig) == null ? void 0 : _a.fields) || []).forEach((field) => {\n      const cell = document.createElement(\"div\");\n      cell.dataset.fieldId = field.id;\n      cell.dataset.groupId = group.id;\n      const lbl = document.createElement(\"label\");\n      lbl.dataset.enLabel = field.labelEn || \"\";\n      lbl.dataset.frLabel = field.labelFr || \"\";\n      lbl.dataset.nlLabel = field.labelNl || \"\";\n      lbl.textContent = \"\";\n      if (field.required) {\n        const star = document.createElement(\"span\");\n        star.className = \"required-star\";\n        star.textContent = \"*\";\n        lbl.appendChild(star);\n      }\n      const labelText = document.createElement(\"span\");\n      labelText.dataset.labelText = \"true\";\n      labelText.textContent = field.labelEn || \"\";\n      lbl.appendChild(labelText);\n      cell.appendChild(lbl);\n      let input;\n      if (field.type === \"CHOICE\") {\n        const select = document.createElement(\"select\");\n        select.dataset.fieldId = field.id;\n        select.dataset.labelEn = (field.labelEn || \"\").toLowerCase();\n        const emptyOpt = document.createElement(\"option\");\n        emptyOpt.value = \"\";\n        emptyOpt.textContent = \"\";\n        select.appendChild(emptyOpt);\n        (field.options || []).forEach((opt, idx) => {\n          var _a2, _b;\n          const option = document.createElement(\"option\");\n          option.value = opt;\n          option.dataset.enLabel = opt;\n          option.dataset.frLabel = ((_a2 = field.optionsFr) == null ? void 0 : _a2[idx]) || opt;\n          option.dataset.nlLabel = ((_b = field.optionsNl) == null ? void 0 : _b[idx]) || opt;\n          option.textContent = opt;\n          select.appendChild(option);\n        });\n        select.dataset.originalOptions = JSON.stringify({ en: field.options || [], fr: field.optionsFr || [], nl: field.optionsNl || [] });\n        if (field.optionFilter) select.dataset.dependsOn = field.optionFilter.dependsOn;\n        input = select;\n      } else if (field.type === \"CHECKBOX\") {\n        const wrap = document.createElement(\"div\");\n        wrap.dataset.fieldName = group.id + \"__\" + field.id;\n        wrap.dataset.fieldId = field.id;\n        wrap.dataset.labelEn = (field.labelEn || \"\").toLowerCase();\n        (field.options || []).forEach((opt, idx) => {\n          var _a2, _b;\n          const checkbox = document.createElement(\"label\");\n          checkbox.className = \"inline\";\n          checkbox.style.fontWeight = \"400\";\n          checkbox.dataset.enLabel = opt;\n          checkbox.dataset.frLabel = ((_a2 = field.optionsFr) == null ? void 0 : _a2[idx]) || opt;\n          checkbox.dataset.nlLabel = ((_b = field.optionsNl) == null ? void 0 : _b[idx]) || opt;\n          const cb = document.createElement(\"input\");\n          cb.type = \"checkbox\";\n          cb.value = opt;\n          cb.name = group.id + \"__\" + field.id;\n          const span = document.createElement(\"span\");\n          span.className = \"option-label\";\n          span.textContent = opt;\n          checkbox.appendChild(cb);\n          checkbox.appendChild(span);\n          wrap.appendChild(checkbox);\n        });\n        wrap.dataset.originalOptions = JSON.stringify({ en: field.options || [], fr: field.optionsFr || [], nl: field.optionsNl || [] });\n        if (field.optionFilter) wrap.dataset.dependsOn = field.optionFilter.dependsOn;\n        input = wrap;\n      } else {\n        const inp = document.createElement(\"input\");\n        inp.type = field.type === \"NUMBER\" ? \"number\" : \"text\";\n        if (field.type === \"NUMBER\") inp.step = \"any\";\n        inp.name = group.id + \"__\" + field.id;\n        input = inp;\n      }\n      if (input && input.tagName !== \"DIV\") {\n        const cast = input;\n        cast.required = !!field.required;\n        cast.name = group.id + \"__\" + field.id;\n        cast.dataset.fieldId = field.id;\n        cast.dataset.labelEn = (field.labelEn || \"\").toLowerCase();\n        if (presetValues[field.id] !== void 0 && \"value\" in cast) {\n          cast.value = presetValues[field.id];\n        }\n      }\n      cell.appendChild(input);\n      row.appendChild(cell);\n    });\n    const actions = document.createElement(\"div\");\n    const removeBtn = document.createElement(\"button\");\n    removeBtn.type = \"button\";\n    removeBtn.className = \"secondary\";\n    removeBtn.textContent = \"Remove\";\n    removeBtn.addEventListener(\"click\", () => {\n      if (row.parentElement) row.parentElement.removeChild(row);\n      computeLineItemTotals(group, formEl);\n    });\n    actions.appendChild(removeBtn);\n    row.appendChild(actions);\n    row.addEventListener(\"input\", () => computeLineItemTotals(group, formEl));\n    row.addEventListener(\"change\", () => computeLineItemTotals(group, formEl));\n    rowsWrapper.appendChild(row);\n    applyFilters({ definition: { questions: [group] }, language: \"EN\", formEl, scopeRow: row });\n    applyVisibility({ definition: { questions: [group] }, language: \"EN\", formEl });\n    computeLineItemTotals(group, formEl);\n  }\n  function computeLineItemTotals(group, formEl) {\n    var _a, _b;\n    if (group.type !== \"LINE_ITEM_GROUP\" || !((_b = (_a = group.lineItemConfig) == null ? void 0 : _a.totals) == null ? void 0 : _b.length)) return;\n    const container = formEl.querySelector('[data-line-item=\"' + group.id + '\"]');\n    if (!container) return;\n    const holder = container.querySelector(\"[data-line-totals]\");\n    if (!holder) return;\n    const rows = Array.from(container.querySelectorAll(\".line-item-row\")).filter(\n      (r) => !r.classList.contains(\"is-hidden-field\") && !isEmptyLineItemRow(r)\n    );\n    holder.innerHTML = \"\";\n    const rowData = rows.map((row) => {\n      var _a2;\n      const values = {};\n      (((_a2 = group.lineItemConfig) == null ? void 0 : _a2.fields) || []).forEach((field) => {\n        var _a3;\n        const name = group.id + \"__\" + field.id;\n        const val = ((_a3 = row.querySelector('[name=\"' + name + '\"]')) == null ? void 0 : _a3.value) || \"\";\n        values[field.id] = val;\n      });\n      return { id: row.dataset.rowId || \"\", values };\n    });\n    const totals = computeTotals({ config: group.lineItemConfig, rows: rowData }, \"EN\");\n    totals.forEach((t) => {\n      const pill = document.createElement(\"div\");\n      pill.className = \"line-item-total-pill\";\n      pill.textContent = t.label ? t.label + \": \" + t.value : String(t.value);\n      holder.appendChild(pill);\n    });\n  }\n\n  // src/web/views/router.ts\n  function createViewRouter(definition, ctx) {\n    let current = \"form\";\n    const listeners2 = [];\n    function render(view) {\n      var _a, _b, _c;\n      current = view;\n      switch (view) {\n        case \"form\":\n          ctx.renderForm();\n          break;\n        case \"list\":\n          (_a = ctx.renderList) == null ? void 0 : _a.call(ctx);\n          break;\n        case \"summary\":\n          (_b = ctx.renderSummary) == null ? void 0 : _b.call(ctx);\n          break;\n        case \"followup\":\n          (_c = ctx.renderFollowup) == null ? void 0 : _c.call(ctx);\n          break;\n        default:\n          ctx.renderForm();\n      }\n      listeners2.forEach((l) => l(view, current));\n    }\n    return {\n      get current() {\n        return current;\n      },\n      goTo: (view) => render(view),\n      onChange: (listener) => {\n        listeners2.push(listener);\n      }\n    };\n  }\n\n  // src/web/views/listView.ts\n  function renderListView(opts) {\n    const { mount, definition, language, fetchRows, onSelectRow } = opts;\n    mount.innerHTML = \"\";\n    const title = document.createElement(\"h2\");\n    title.textContent = definition.title + \" - List\";\n    mount.appendChild(title);\n    const status = document.createElement(\"div\");\n    status.textContent = \"Loading...\";\n    mount.appendChild(status);\n    if (!fetchRows) {\n      status.textContent = language === \"FR\" ? \"Aucune source de donn\\xE9es.\" : language === \"NL\" ? \"Geen gegevensbron.\" : \"No data source.\";\n      return;\n    }\n    const config = definition.listView;\n    const columns = (config == null ? void 0 : config.columns) && config.columns.length ? config.columns : definition.questions.map((q) => ({ fieldId: q.id, label: q.label }));\n    const table = document.createElement(\"table\");\n    table.style.width = \"100%\";\n    table.style.borderCollapse = \"collapse\";\n    const header = document.createElement(\"tr\");\n    columns.forEach((col) => {\n      const th = document.createElement(\"th\");\n      th.style.textAlign = \"left\";\n      th.style.borderBottom = \"1px solid #e5e7eb\";\n      th.style.padding = \"6px\";\n      th.textContent = resolveLabel(col.label, col.fieldId, language);\n      header.appendChild(th);\n    });\n    const thMeta = document.createElement(\"th\");\n    thMeta.style.textAlign = \"left\";\n    thMeta.style.borderBottom = \"1px solid #e5e7eb\";\n    thMeta.style.padding = \"6px\";\n    thMeta.textContent = \"Updated\";\n    header.appendChild(thMeta);\n    table.appendChild(header);\n    const pager = document.createElement(\"div\");\n    pager.style.margin = \"8px 0\";\n    let nextToken;\n    const renderPage = (token) => {\n      status.textContent = language === \"FR\" ? \"Chargement...\" : language === \"NL\" ? \"Bezig met laden...\" : \"Loading...\";\n      fetchRows(token).then((res) => {\n        status.textContent = \"\";\n        table.querySelectorAll(\"tr:not(:first-child)\").forEach((row) => row.remove());\n        (res.items || []).forEach((row) => {\n          const tr = document.createElement(\"tr\");\n          tr.style.cursor = onSelectRow ? \"pointer\" : \"default\";\n          columns.forEach((col) => {\n            const td = document.createElement(\"td\");\n            td.style.padding = \"6px\";\n            td.style.borderBottom = \"1px solid #f1f5f9\";\n            td.textContent = valueToString(row[col.fieldId]);\n            tr.appendChild(td);\n          });\n          const meta = document.createElement(\"td\");\n          meta.style.padding = \"6px\";\n          meta.style.borderBottom = \"1px solid #f1f5f9\";\n          meta.textContent = row.updatedAt || row.createdAt || \"\";\n          tr.appendChild(meta);\n          if (onSelectRow) {\n            tr.addEventListener(\"click\", () => onSelectRow(row));\n          }\n          table.appendChild(tr);\n        });\n        nextToken = res.nextPageToken;\n        pager.innerHTML = \"\";\n        if (nextToken) {\n          const btn = document.createElement(\"button\");\n          btn.textContent = language === \"FR\" ? \"Suivant\" : language === \"NL\" ? \"Volgende\" : \"Next\";\n          btn.addEventListener(\"click\", () => renderPage(nextToken));\n          pager.appendChild(btn);\n        } else if (!res.items || !res.items.length) {\n          status.textContent = language === \"FR\" ? \"Aucune donn\\xE9e.\" : language === \"NL\" ? \"Geen gegevens.\" : \"No data.\";\n        }\n      }).catch(() => {\n        status.textContent = language === \"FR\" ? \"Erreur de chargement.\" : language === \"NL\" ? \"Fout bij laden.\" : \"Failed to load.\";\n      });\n    };\n    mount.appendChild(table);\n    mount.appendChild(pager);\n    renderPage();\n  }\n  function resolveLabel(label, fallback, language) {\n    if (!label) return fallback;\n    if (typeof label === \"string\") return label;\n    const key2 = (language || \"en\").toString().toLowerCase();\n    return label[key2] || label.en || fallback;\n  }\n  function valueToString(val) {\n    if (val === null || val === void 0) return \"\";\n    if (Array.isArray(val)) return val.join(\", \");\n    if (val instanceof Date) return val.toISOString();\n    return val.toString();\n  }\n\n  // src/web/views/summaryView.ts\n  function renderSummaryView(opts) {\n    const { mount, definition, language, payload } = opts;\n    mount.innerHTML = \"\";\n    const title = document.createElement(\"h2\");\n    title.textContent = language === \"FR\" ? \"R\\xE9sum\\xE9\" : language === \"NL\" ? \"Samenvatting\" : \"Summary\";\n    mount.appendChild(title);\n    const langKey = (language || \"EN\").toLowerCase();\n    definition.questions.forEach((q) => {\n      const block = document.createElement(\"div\");\n      block.style.padding = \"8px 0\";\n      const label = document.createElement(\"div\");\n      label.style.fontWeight = \"800\";\n      label.textContent = q.label[langKey] || q.label.en || q.id;\n      const value = document.createElement(\"div\");\n      if (q.type === \"LINE_ITEM_GROUP\") {\n        const raw = payload[`${q.id}_json`] || payload[q.id];\n        const rows = parseLineItems(raw);\n        if (rows.length) {\n          value.appendChild(renderLineItemList(rows, q, langKey));\n        } else {\n          value.textContent = \"\";\n        }\n      } else {\n        const val = payload[q.id];\n        value.textContent = Array.isArray(val) ? val.join(\", \") : val || \"\";\n      }\n      block.appendChild(label);\n      block.appendChild(value);\n      mount.appendChild(block);\n    });\n  }\n  function parseLineItems(raw) {\n    if (!raw) return [];\n    if (Array.isArray(raw)) return raw;\n    if (typeof raw === \"string\") {\n      try {\n        const parsed = JSON.parse(raw);\n        return Array.isArray(parsed) ? parsed : [];\n      } catch (_) {\n        return [];\n      }\n    }\n    return [];\n  }\n  function renderLineItemList(rows, question, languageKey) {\n    const list = document.createElement(\"ul\");\n    list.style.margin = \"4px 0 0 16px\";\n    list.style.padding = \"0 0 0 12px\";\n    rows.forEach((row) => {\n      const li = document.createElement(\"li\");\n      li.style.marginBottom = \"4px\";\n      li.textContent = formatLineItemRow(row, question, languageKey);\n      list.appendChild(li);\n    });\n    return list;\n  }\n  function formatLineItemRow(row, question, languageKey) {\n    var _a;\n    if (!row || typeof row !== \"object\" || !((_a = question.lineItemConfig) == null ? void 0 : _a.fields)) return \"\";\n    const parts = [];\n    question.lineItemConfig.fields.forEach((field) => {\n      const raw = row[field.id];\n      if (!raw) return;\n      const label = field[`label${languageKey.toUpperCase()}`] || field.labelEn || field.id;\n      parts.push(`${label}: ${raw}`);\n    });\n    return parts.join(\" \\u2022 \");\n  }\n\n  // src/web/views/followupView.ts\n  function renderFollowupView(opts) {\n    const { mount, language, actions = [] } = opts;\n    mount.innerHTML = \"\";\n    const title = document.createElement(\"h2\");\n    title.textContent = language === \"FR\" ? \"Suivi\" : language === \"NL\" ? \"Vervolg\" : \"Follow-up\";\n    mount.appendChild(title);\n    if (!actions.length) {\n      const empty = document.createElement(\"div\");\n      empty.textContent = language === \"FR\" ? \"Aucune action disponible.\" : language === \"NL\" ? \"Geen acties beschikbaar.\" : \"No follow-up actions available.\";\n      mount.appendChild(empty);\n      return;\n    }\n    actions.forEach((action) => {\n      const btn = document.createElement(action.href ? \"a\" : \"button\");\n      btn.textContent = action.label;\n      btn.style = \"display:inline-block;margin:4px 6px;padding:10px 14px;border:1px solid #e2e8f0;border-radius:10px;text-decoration:none;color:#0f172a;background:#fff;\";\n      if (action.href) {\n        btn.href = action.href;\n        btn.target = \"_blank\";\n      } else if (action.onClick) {\n        btn.addEventListener(\"click\", action.onClick);\n      }\n      mount.appendChild(btn);\n    });\n  }\n\n  // src/web/data/submissions.ts\n  async function fetchSubmissionsPage(opts) {\n    var _a;\n    const { formKey, projection, pageSize = 10, pageToken } = opts;\n    const runner = (_a = google == null ? void 0 : google.script) == null ? void 0 : _a.run;\n    if (!runner || typeof runner.withSuccessHandler !== \"function\") {\n      return { items: [], totalCount: 0, nextPageToken: void 0 };\n    }\n    return new Promise((resolve) => {\n      var _a2, _b;\n      (_b = (_a2 = runner.withSuccessHandler((res) => resolve(res || { items: [], totalCount: 0 })).withFailureHandler(() => resolve({ items: [], totalCount: 0 }))) == null ? void 0 : _a2.fetchSubmissions) == null ? void 0 : _b.call(_a2, formKey || \"\", projection || void 0, pageSize, pageToken);\n    });\n  }\n\n  // src/web/data/submit.ts\n  async function submitWithDedup(payload) {\n    var _a;\n    const runner = (_a = google == null ? void 0 : google.script) == null ? void 0 : _a.run;\n    if (!runner || typeof runner.withSuccessHandler !== \"function\") {\n      return { success: false, message: \"Submission unavailable offline.\" };\n    }\n    return new Promise((resolve) => {\n      var _a2, _b, _c, _d;\n      try {\n        const pipeline = (_c = (_b = (_a2 = runner == null ? void 0 : runner.withSuccessHandler) == null ? void 0 : _a2.call(runner, (res) => resolve(res || { success: false, message: \"Unknown response\" }))) == null ? void 0 : _b.withFailureHandler) == null ? void 0 : _c.call(_b, (err) => resolve({ success: false, message: err && err.message || \"Submit failed\" }));\n        (_d = pipeline == null ? void 0 : pipeline.saveSubmissionWithId) == null ? void 0 : _d.call(pipeline, payload);\n      } catch (err) {\n        resolve({ success: false, message: (err == null ? void 0 : err.message) || \"Submit failed\" });\n      }\n    });\n  }\n\n  // src/web/main.ts\n  function bootstrapWebForm(definition, formKey, opts) {\n    var _a;\n    const initialLang = ((_a = definition.languages) == null ? void 0 : _a[0]) || \"EN\";\n    setState({ language: initialLang });\n    if (opts == null ? void 0 : opts.onReady) opts.onReady(definition, formKey);\n    if (opts == null ? void 0 : opts.mountListView) {\n      renderListView({\n        mount: opts.mountListView,\n        definition,\n        language: initialLang,\n        fetchRows: (pageToken) => fetchSubmissionsPage({ formKey, pageToken }),\n        onSelectRow: (row) => {\n          setState({ recordMeta: { id: row.id, createdAt: row.createdAt, updatedAt: row.updatedAt } });\n        }\n      });\n    }\n    if (typeof console !== \"undefined\") {\n      console.info(\"[WebFormApp] bootstrapped\", { formKey, language: initialLang });\n    }\n  }\n  var globalWindow = typeof globalThis === \"object\" && \"document\" in globalThis ? globalThis : void 0;\n  if (globalWindow) {\n    const applyFiltersAndVisibility = (opts) => {\n      const { definition, language, formEl, scopeRow } = opts;\n      applyFilters({ definition, language, formEl, scopeRow });\n      applyVisibility({ definition, language, formEl });\n    };\n    const existingApp = globalWindow.WebFormApp || {};\n    globalWindow.WebFormApp = {\n      ...existingApp,\n      bootstrapWebForm,\n      updateLanguageLabels,\n      applyFiltersAndVisibility,\n      validateFormWithBundle,\n      resolveFieldElement,\n      computeLineTotals: computeTotals,\n      syncLineItemPayload,\n      buildPayloadFromForm,\n      handleSelectionEffects,\n      hydrateDataSources,\n      addLineItemRowFromBundle,\n      computeLineItemTotalsLegacy: computeLineItemTotals,\n      createViewRouter,\n      renderListView,\n      renderSummaryView,\n      renderFollowupView,\n      fetchSubmissionsPage,\n      submitWithDedup\n    };\n  }\n})();\n";
