// Auto-generated by scripts/embed-web-bundle.js. Do not edit by hand.
// Contains the bundled client code injected into the web form template.
export const WEB_FORM_BUNDLE: string = "\"use strict\";\nvar WebFormApp = (() => {\n  var __defProp = Object.defineProperty;\n  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;\n  var __getOwnPropNames = Object.getOwnPropertyNames;\n  var __hasOwnProp = Object.prototype.hasOwnProperty;\n  var __export = (target, all) => {\n    for (var name in all)\n      __defProp(target, name, { get: all[name], enumerable: true });\n  };\n  var __copyProps = (to, from, except, desc) => {\n    if (from && typeof from === \"object\" || typeof from === \"function\") {\n      for (let key2 of __getOwnPropNames(from))\n        if (!__hasOwnProp.call(to, key2) && key2 !== except)\n          __defProp(to, key2, { get: () => from[key2], enumerable: !(desc = __getOwnPropDesc(from, key2)) || desc.enumerable });\n    }\n    return to;\n  };\n  var __toCommonJS = (mod) => __copyProps(__defProp({}, \"__esModule\", { value: true }), mod);\n\n  // src/web/main.ts\n  var main_exports = {};\n  __export(main_exports, {\n    bootstrapWebForm: () => bootstrapWebForm\n  });\n\n  // src/web/state/store.ts\n  var state = {\n    language: \"EN\",\n    values: {},\n    lineItems: {},\n    submitting: false,\n    recordMeta: {}\n  };\n  var listeners = /* @__PURE__ */ new Set();\n  function setState(next) {\n    const prev = state;\n    state = {\n      ...state,\n      ...next,\n      values: next.values ? { ...prev.values, ...next.values } : prev.values,\n      lineItems: next.lineItems ? { ...prev.lineItems, ...next.lineItems } : prev.lineItems,\n      recordMeta: next.recordMeta ? { ...prev.recordMeta || {}, ...next.recordMeta } : prev.recordMeta\n    };\n    listeners.forEach((l) => l(state, prev));\n    return state;\n  }\n\n  // src/web/i18n.ts\n  function resolveLocalizedString(value, language, fallback = \"\") {\n    if (!value && fallback) return fallback;\n    if (typeof value === \"string\") return value;\n    const key2 = (language || \"EN\").toString().toLowerCase();\n    return (value == null ? void 0 : value[key2]) || (value == null ? void 0 : value.en) || fallback;\n  }\n\n  // src/web/legacy/language.ts\n  function updateLanguageLabels(options) {\n    const { language, root = document } = options;\n    const langKey = (language || \"en\").toString().toLowerCase();\n    root.querySelectorAll(\"[data-en-label]\").forEach((el) => {\n      var _a, _b, _c;\n      const label = ((_a = el.dataset) == null ? void 0 : _a[`${langKey}Label`]) || ((_b = el.dataset) == null ? void 0 : _b.enLabel) || \"\";\n      const textTarget = (_c = el.querySelector) == null ? void 0 : _c.call(el, \"[data-label-text]\");\n      if (textTarget) {\n        textTarget.textContent = label;\n      } else {\n        el.textContent = label;\n      }\n    });\n    root.querySelectorAll(\"option[data-en-label]\").forEach((opt) => {\n      var _a, _b;\n      const label = ((_a = opt.dataset) == null ? void 0 : _a[`${langKey}Label`]) || ((_b = opt.dataset) == null ? void 0 : _b.enLabel) || \"\";\n      opt.textContent = label;\n    });\n    root.querySelectorAll(\"button[data-default-label]\").forEach((btn) => {\n      var _a, _b;\n      const defaultLabel = ((_a = btn.dataset) == null ? void 0 : _a.defaultLabel) || \"+ Add line\";\n      let labels;\n      try {\n        labels = ((_b = btn.dataset) == null ? void 0 : _b.addLabels) ? JSON.parse(btn.dataset.addLabels) : void 0;\n      } catch (_) {\n        labels = void 0;\n      }\n      btn.textContent = resolveLocalizedString(labels, language, defaultLabel);\n    });\n  }\n\n  // src/web/rules/filter.ts\n  var normalize = (val) => {\n    if (val === null || val === void 0) return \"\";\n    return val.toString();\n  };\n  function computeAllowedOptions(filter, options, dependencyValues) {\n    if (!filter) return options.en || [];\n    const depValues = dependencyValues.map((v) => normalize(v));\n    const candidateKeys = [];\n    if (depValues.length > 1) candidateKeys.push(depValues.join(\"||\"));\n    depValues.filter(Boolean).forEach((v) => candidateKeys.push(v));\n    candidateKeys.push(\"*\");\n    const match = candidateKeys.reduce((acc, key2) => acc || filter.optionMap[key2], void 0);\n    if (match) return match;\n    return [];\n  }\n  function buildLocalizedOptions(options, allowed, language) {\n    const langKey = (language || \"en\").toString().toLowerCase();\n    const labels = options[langKey] || options.en || [];\n    const baseOpts = options.en || labels;\n    const allowedSet = allowed && allowed.length ? new Set(allowed) : null;\n    const values = allowedSet ? allowed : baseOpts;\n    const items = [];\n    values.forEach((value, idx) => {\n      var _a, _b, _c;\n      const base = baseOpts[idx] || value;\n      const labelIdx = baseOpts.indexOf(base);\n      const label = labelIdx >= 0 ? labels[labelIdx] || base : value;\n      items.push({\n        value: base,\n        label,\n        labels: {\n          en: ((_a = options.en) == null ? void 0 : _a[labelIdx]) || base,\n          fr: ((_b = options.fr) == null ? void 0 : _b[labelIdx]) || base,\n          nl: ((_c = options.nl) == null ? void 0 : _c[labelIdx]) || base\n        }\n      });\n    });\n    return items;\n  }\n\n  // src/web/legacy/dom.ts\n  function getValue(formEl, name) {\n    const els = formEl.querySelectorAll('[name=\"' + name + '\"]');\n    if (!els || els.length === 0) return \"\";\n    const el = els[0];\n    if (el instanceof HTMLSelectElement) return el.value;\n    if (el instanceof HTMLInputElement) {\n      if (el.type === \"checkbox\") {\n        return Array.from(els).filter((e) => e instanceof HTMLInputElement && e.checked).map((e) => e.value);\n      }\n      return el.value;\n    }\n    if (el instanceof HTMLTextAreaElement) return el.value;\n    return \"\";\n  }\n  function getRowValue(row, name) {\n    let els = row.querySelectorAll('[name=\"' + name + '\"]');\n    if (!els || els.length === 0) {\n      const wrapper = row.querySelector('[data-field-name=\"' + name + '\"]');\n      if (wrapper) {\n        els = wrapper.querySelectorAll(\"input\");\n      }\n    }\n    if (!els || els.length === 0) return \"\";\n    const el = els[0];\n    if (el instanceof HTMLSelectElement) return el.value;\n    if (el instanceof HTMLInputElement) {\n      if (el.type === \"checkbox\") {\n        return Array.from(els).filter((e) => e instanceof HTMLInputElement && e.checked).map((e) => e.value);\n      }\n      return el.value;\n    }\n    if (el instanceof HTMLTextAreaElement) return el.value;\n    return \"\";\n  }\n  function toggleFieldVisibility(holder, shouldHide) {\n    if (!holder) return;\n    if (shouldHide) {\n      holder.classList.add(\"is-hidden-field\");\n      const inputs = holder.querySelectorAll(\"input, select, textarea\");\n      inputs.forEach((input) => {\n        const data = input.dataset || {};\n        if (data.originalRequired === void 0) data.originalRequired = input.required ? \"true\" : \"false\";\n        input.required = false;\n        if (input instanceof HTMLInputElement && (input.type === \"checkbox\" || input.type === \"radio\")) {\n          input.checked = false;\n        } else {\n          try {\n            input.value = \"\";\n          } catch (_) {\n          }\n        }\n      });\n      const err = holder.querySelector(\".field-error\");\n      if (err) err.remove();\n    } else {\n      holder.classList.remove(\"is-hidden-field\");\n      const inputs = holder.querySelectorAll(\"input, select, textarea\");\n      inputs.forEach((input) => {\n        const data = input.dataset || {};\n        if (data.originalRequired === \"true\") input.required = true;\n      });\n    }\n  }\n  function findFieldElement(fieldId, formEl, scope) {\n    const ctx = scope || formEl;\n    return ctx.querySelector('[data-field-id=\"' + fieldId + '\"]') || ctx.querySelector('[name=\"' + fieldId + '\"]') || ctx.querySelector('[name$=\"__' + fieldId + '\"]') || ctx.querySelector('[data-field-name$=\"__' + fieldId + '\"]');\n  }\n  function isFieldHidden(fieldId, formEl, scope) {\n    const el = findFieldElement(fieldId, formEl, scope);\n    if (!el) return false;\n    const hiddenHolder = el.closest(\".is-hidden-field\");\n    return !!hiddenHolder;\n  }\n  function isEmptyLineItemRow(row) {\n    const inputs = Array.from(row.querySelectorAll(\"input, select, textarea\"));\n    for (const input of inputs) {\n      if (input instanceof HTMLInputElement) {\n        if (input.type === \"checkbox\" || input.type === \"radio\") {\n          if (input.checked) return false;\n        } else {\n          const val = (input.value || \"\").trim();\n          if (val !== \"\") return false;\n        }\n      } else if (input instanceof HTMLSelectElement) {\n        const val = (input.value || \"\").trim();\n        if (val !== \"\") return false;\n      } else if (input instanceof HTMLTextAreaElement) {\n        const val = (input.value || \"\").trim();\n        if (val !== \"\") return false;\n      }\n    }\n    return true;\n  }\n\n  // src/web/legacy/filters.ts\n  function applyFilterToElement(el, filter, options, language, dependencyValues) {\n    var _a;\n    const allowed = computeAllowedOptions(filter, options, dependencyValues);\n    const langKey = (language || \"en\").toString().toLowerCase();\n    if (el.tagName === \"SELECT\") {\n      const select = el;\n      const previous = select.value;\n      const currentSelections = previous ? [previous] : [];\n      const extras = currentSelections.filter((v) => v && !allowed.includes(v));\n      const allowedSet = new Set((allowed || []).map((v) => (v || \"\").toString().toLowerCase()));\n      const combined = [];\n      const seen = /* @__PURE__ */ new Set();\n      [...allowed, ...extras].forEach((v) => {\n        if (seen.has(v)) return;\n        seen.add(v);\n        combined.push(v);\n      });\n      select.innerHTML = \"\";\n      combined.forEach((base) => {\n        var _a2, _b, _c;\n        const optIdx = Array.isArray(options.en) ? options.en.indexOf(base) : -1;\n        const label = optIdx >= 0 ? (options[langKey] || [])[optIdx] || base : base;\n        const opt = document.createElement(\"option\");\n        opt.value = base;\n        opt.dataset.enLabel = optIdx >= 0 ? ((_a2 = options.en) == null ? void 0 : _a2[optIdx]) || base : base;\n        opt.dataset.frLabel = optIdx >= 0 ? ((_b = options.fr) == null ? void 0 : _b[optIdx]) || base : base;\n        opt.dataset.nlLabel = optIdx >= 0 ? ((_c = options.nl) == null ? void 0 : _c[optIdx]) || base : base;\n        opt.textContent = label;\n        if (previous && previous === base) opt.selected = true;\n        if (!allowedSet.size || allowedSet.has(base.toLowerCase()) || extras.includes(base)) {\n          select.appendChild(opt);\n        }\n      });\n    } else {\n      const wrapper = el.tagName === \"DIV\" ? el : el.parentElement;\n      if (!wrapper) return;\n      const inputs = wrapper.querySelectorAll('input[type=\"checkbox\"]');\n      const prevChecked = Array.from(inputs).filter((c) => c.checked).map((c) => c.value);\n      const extras = prevChecked.filter((v) => v && !allowed.includes(v));\n      const allowedSet = new Set((allowed || []).map((v) => (v || \"\").toString().toLowerCase()));\n      const combined = [];\n      const seen = /* @__PURE__ */ new Set();\n      [...allowed, ...extras].forEach((v) => {\n        if (seen.has(v)) return;\n        seen.add(v);\n        combined.push(v);\n      });\n      const nameAttr = ((_a = wrapper.dataset) == null ? void 0 : _a.fieldName) || wrapper.getAttribute(\"name\") || \"\";\n      wrapper.innerHTML = \"\";\n      combined.forEach((base, idx) => {\n        var _a2, _b, _c;\n        const localized = buildLocalizedOptions(options, [base], language)[0];\n        const id = nameAttr + \"_\" + idx + \"_\" + Math.random().toString(16).slice(2);\n        const l = document.createElement(\"label\");\n        l.className = \"inline\";\n        l.style.fontWeight = \"400\";\n        l.htmlFor = id;\n        l.dataset.enLabel = ((_a2 = localized == null ? void 0 : localized.labels) == null ? void 0 : _a2.en) || base;\n        l.dataset.frLabel = ((_b = localized == null ? void 0 : localized.labels) == null ? void 0 : _b.fr) || base;\n        l.dataset.nlLabel = ((_c = localized == null ? void 0 : localized.labels) == null ? void 0 : _c.nl) || base;\n        const cb = document.createElement(\"input\");\n        cb.type = \"checkbox\";\n        cb.name = nameAttr;\n        cb.id = id;\n        cb.value = base;\n        if (prevChecked.includes(base)) cb.checked = true;\n        const span = document.createElement(\"span\");\n        span.className = \"option-label\";\n        span.textContent = (localized == null ? void 0 : localized.label) || base;\n        l.appendChild(cb);\n        l.appendChild(span);\n        if (!allowedSet.size || allowedSet.has(base.toLowerCase()) || prevChecked.includes(base)) {\n          wrapper.appendChild(l);\n        }\n      });\n    }\n  }\n  function applyFilters(options) {\n    const { definition, language, formEl, scopeRow } = options;\n    const getDependencyValues = (dependsOn, row, linePrefix) => {\n      const ids = Array.isArray(dependsOn) ? dependsOn : [dependsOn];\n      return ids.map((id) => {\n        const prefixed = linePrefix ? `${linePrefix}__${id}` : id;\n        let val = row ? getRowValue(row, prefixed) : getValue(formEl, prefixed);\n        if ((val === \"\" || Array.isArray(val) && val.length === 0) && linePrefix) {\n          val = getValue(formEl, id);\n        }\n        if (Array.isArray(val)) return val.join(\"|\");\n        return val;\n      });\n    };\n    definition.questions.forEach((q) => {\n      if ((q.type === \"CHOICE\" || q.type === \"CHECKBOX\") && q.optionFilter) {\n        const target = q.type === \"CHECKBOX\" ? formEl.querySelector('[data-field-name=\"' + q.id + '\"]') || formEl.querySelector('[name=\"' + q.id + '\"]') : formEl.querySelector('[name=\"' + q.id + '\"]');\n        if (target) {\n          applyFilterToElement(target, q.optionFilter, q.options || { en: [], fr: [], nl: [] }, language, getDependencyValues(q.optionFilter.dependsOn));\n        }\n      }\n      if (q.type === \"LINE_ITEM_GROUP\") {\n        const container = formEl.querySelector('[data-line-item=\"' + q.id + '\"]');\n        if (!container) return;\n        const rows = scopeRow ? [scopeRow] : Array.from(container.querySelectorAll(\".line-item-row\"));\n        rows.forEach((row) => {\n          var _a;\n          (((_a = q.lineItemConfig) == null ? void 0 : _a.fields) || []).forEach((field) => {\n            if (!field.optionFilter) return;\n            const name = q.id + \"__\" + field.id;\n            const el = field.type === \"CHECKBOX\" ? row.querySelector('[data-field-name=\"' + name + '\"]') || row.querySelector('[name=\"' + name + '\"]') : row.querySelector('[name=\"' + name + '\"]');\n            if (el) {\n              applyFilterToElement(\n                el,\n                field.optionFilter,\n                { en: field.options || [], fr: field.optionsFr || [], nl: field.optionsNl || [] },\n                language,\n                getDependencyValues(field.optionFilter.dependsOn, row, q.id)\n              );\n            }\n          });\n        });\n      }\n    });\n  }\n\n  // src/web/rules/visibility.ts\n  function matchesWhen(value, when) {\n    if (!when) return true;\n    const values = Array.isArray(value) ? value : [value];\n    if (when.equals !== void 0) {\n      const expected = Array.isArray(when.equals) ? when.equals : [when.equals];\n      if (!values.some((v) => expected.includes(v))) return false;\n    }\n    const numericVals = values.map((v) => Number(v)).filter((v) => !isNaN(v));\n    if (when.greaterThan !== void 0) {\n      if (!numericVals.some((v) => v > Number(when.greaterThan))) return false;\n    }\n    if (when.lessThan !== void 0) {\n      if (!numericVals.some((v) => v < Number(when.lessThan))) return false;\n    }\n    return true;\n  }\n  function resolveVisibilityValue(condition, ctx, rowId, linePrefix) {\n    if (!condition) return \"\";\n    const scopedId = linePrefix ? `${linePrefix}__${condition.fieldId}` : condition.fieldId;\n    const direct = rowId && ctx.getLineValue ? ctx.getLineValue(rowId, scopedId) : ctx.getValue(scopedId);\n    if (direct !== void 0 && direct !== \"\" && direct !== null) return direct;\n    if (linePrefix) return ctx.getValue(condition.fieldId);\n    return direct;\n  }\n  function shouldHideField(visibility, ctx, options) {\n    if (!visibility) return false;\n    const rowId = options == null ? void 0 : options.rowId;\n    const linePrefix = options == null ? void 0 : options.linePrefix;\n    const showMatch = visibility.showWhen ? matchesWhen(resolveVisibilityValue(visibility.showWhen, ctx, rowId, linePrefix), visibility.showWhen) : true;\n    const hideMatch = visibility.hideWhen ? matchesWhen(resolveVisibilityValue(visibility.hideWhen, ctx, rowId, linePrefix), visibility.hideWhen) : false;\n    if (visibility.showWhen && !showMatch) return true;\n    if (visibility.hideWhen && hideMatch) return true;\n    return false;\n  }\n\n  // src/web/legacy/visibility.ts\n  function applyVisibility(options) {\n    const { definition, formEl } = options;\n    definition.questions.forEach((q) => {\n      if (q.visibility) {\n        const ctx = { getValue: (fieldId) => getValue(formEl, fieldId) };\n        const shouldHide = shouldHideField(q.visibility, ctx, { linePrefix: q.type === \"LINE_ITEM_GROUP\" ? q.id : void 0 });\n        const holder = formEl.querySelector('[data-qid=\"' + q.id + '\"]');\n        toggleFieldVisibility(holder, shouldHide);\n      }\n      if (q.type === \"LINE_ITEM_GROUP\") {\n        const container = formEl.querySelector('[data-line-item=\"' + q.id + '\"]');\n        if (!container) return;\n        const rows = Array.from(container.querySelectorAll(\".line-item-row\"));\n        rows.forEach((row) => {\n          var _a;\n          const rowCtx = {\n            getValue: (fieldId) => getValue(formEl, fieldId),\n            getLineValue: (_rowId, fieldId) => getRowValue(row, fieldId)\n          };\n          (((_a = q.lineItemConfig) == null ? void 0 : _a.fields) || []).forEach((field) => {\n            var _a2;\n            if (!field.visibility) return;\n            const hide = shouldHideField(field.visibility, rowCtx, { rowId: row.dataset.rowId, linePrefix: q.id });\n            const cell = row.querySelector('[data-field-id=\"' + field.id + '\"][data-group-id=\"' + q.id + '\"]') || ((_a2 = row.querySelector('[name=\"' + q.id + \"__\" + field.id + '\"]')) == null ? void 0 : _a2.closest(\"div\"));\n            toggleFieldVisibility(cell || row, hide);\n          });\n        });\n      }\n    });\n  }\n\n  // src/web/rules/validation.ts\n  var defaultRuleMessages = {\n    required: {\n      en: \"This field is required.\",\n      fr: \"Ce champ est obligatoire.\",\n      nl: \"Dit veld is verplicht.\"\n    },\n    allowed: {\n      en: \"Please use an allowed value.\",\n      fr: \"Veuillez utiliser une valeur autoris\\xE9e.\",\n      nl: \"Gebruik een toegestane waarde.\"\n    },\n    disallowed: {\n      en: \"This combination is not allowed.\",\n      fr: \"Cette combinaison n'est pas autoris\\xE9e.\",\n      nl: \"Deze combinatie is niet toegestaan.\"\n    }\n  };\n  var withLimitMessage = (prefix, limit) => ({\n    en: `${prefix} ${limit}.`,\n    fr: `${prefix} ${limit}.`,\n    nl: `${prefix} ${limit}.`\n  });\n  function checkRule(value, thenCfg, language, message) {\n    var _a, _b;\n    const values = Array.isArray(value) ? value : [value];\n    const customMessage = message ? resolveLocalizedString(message, language, \"\") : \"\";\n    if (thenCfg == null ? void 0 : thenCfg.required) {\n      const hasValue = values.some((v) => {\n        if (v === void 0 || v === null) return false;\n        if (typeof v === \"string\") return v.trim() !== \"\";\n        return true;\n      });\n      if (!hasValue) {\n        return customMessage || resolveLocalizedString(defaultRuleMessages.required, language, \"This field is required.\");\n      }\n    }\n    if ((thenCfg == null ? void 0 : thenCfg.min) !== void 0) {\n      const minVal = Number(thenCfg.min);\n      const numVals = values.map((v) => Number(v)).filter((v) => !isNaN(v));\n      if (numVals.some((v) => v < minVal)) {\n        return customMessage || resolveLocalizedString(withLimitMessage(\"Value must be >=\", thenCfg.min), language, \"Value must be >= \" + thenCfg.min + \".\");\n      }\n    }\n    if ((thenCfg == null ? void 0 : thenCfg.max) !== void 0) {\n      const maxVal = Number(thenCfg.max);\n      const numVals = values.map((v) => Number(v)).filter((v) => !isNaN(v));\n      if (numVals.some((v) => v > maxVal)) {\n        return customMessage || resolveLocalizedString(withLimitMessage(\"Value must be <=\", thenCfg.max), language, \"Value must be <= \" + thenCfg.max + \".\");\n      }\n    }\n    if (((_a = thenCfg == null ? void 0 : thenCfg.allowed) == null ? void 0 : _a.length) && !values.every((v) => {\n      var _a2;\n      return (_a2 = thenCfg.allowed) == null ? void 0 : _a2.includes(v);\n    })) {\n      return customMessage || resolveLocalizedString(defaultRuleMessages.allowed, language, \"Please use an allowed value.\");\n    }\n    if (((_b = thenCfg == null ? void 0 : thenCfg.disallowed) == null ? void 0 : _b.length) && values.some((v) => {\n      var _a2;\n      return (_a2 = thenCfg.disallowed) == null ? void 0 : _a2.includes(v);\n    })) {\n      return customMessage || resolveLocalizedString(defaultRuleMessages.disallowed, language, \"This combination is not allowed.\");\n    }\n    return \"\";\n  }\n  function validateRules(rules, ctx) {\n    const errors = [];\n    rules.forEach((rule) => {\n      const whenValue = ctx.getValue(rule.when.fieldId);\n      if (!matchesWhen(whenValue, rule.when)) return;\n      if (ctx.isHidden && ctx.isHidden(rule.then.fieldId)) return;\n      const targetVal = ctx.getValue(rule.then.fieldId);\n      const msg = checkRule(targetVal, rule.then, ctx.language, rule.message);\n      if (msg) {\n        errors.push({\n          fieldId: rule.then.fieldId,\n          message: msg,\n          scope: \"main\"\n        });\n      }\n    });\n    return errors;\n  }\n\n  // src/web/legacy/validation.ts\n  function getLineItemRowCount(groupId, formEl) {\n    const container = formEl.querySelector('[data-line-item=\"' + groupId + '\"]');\n    if (!container) return 0;\n    return Array.from(container.querySelectorAll(\".line-item-row\")).filter((row) => {\n      return !row.classList.contains(\"is-hidden-field\") && !isEmptyLineItemRow(row);\n    }).length;\n  }\n  function fileInputMissing(name, formEl) {\n    const el = formEl.querySelector('input[type=\"file\"][name=\"' + name + '\"]');\n    if (!el) return false;\n    if (isFieldHidden(name, formEl)) return false;\n    return !(el.files && el.files.length > 0);\n  }\n  function validateFormWithBundle(definition, language, formEl) {\n    const errors = [];\n    const missingRequiredLineItem = definition.questions.find(\n      (q) => q.type === \"LINE_ITEM_GROUP\" && q.required && !isFieldHidden(q.id, formEl) && getLineItemRowCount(q.id, formEl) === 0\n    );\n    if (missingRequiredLineItem) {\n      errors.push({\n        fieldId: missingRequiredLineItem.id,\n        message: language === \"FR\" ? \"Ajoutez au moins une ligne.\" : language === \"NL\" ? \"Voeg minstens \\xE9\\xE9n regel toe.\" : \"Please add at least one line.\",\n        scope: \"main\"\n      });\n      return { errors };\n    }\n    definition.questions.filter((q) => q.type === \"FILE_UPLOAD\" && q.required).forEach((fq) => {\n      if (fileInputMissing(fq.id, formEl)) {\n        errors.push({\n          fieldId: fq.id,\n          message: language === \"FR\" ? \"Veuillez t\\xE9l\\xE9verser un fichier.\" : language === \"NL\" ? \"Upload een bestand.\" : \"Please upload a file.\",\n          scope: \"main\"\n        });\n      }\n    });\n    if (errors.length) return { errors };\n    const mainRules = definition.questions.flatMap((q) => (q.validationRules || []).map((rule) => ({ rule, scope: \"main\" })));\n    const ctx = {\n      language,\n      getValue: (fieldId) => getValue(formEl, fieldId),\n      isHidden: (fieldId) => isFieldHidden(fieldId, formEl)\n    };\n    errors.push(...validateRules(mainRules.map((r) => r.rule), ctx));\n    if (errors.length) return { errors };\n    definition.questions.filter((q) => q.type === \"LINE_ITEM_GROUP\").forEach((group) => {\n      var _a;\n      const container = formEl.querySelector('[data-line-item=\"' + group.id + '\"]');\n      if (!container) return;\n      const rows = Array.from(container.querySelectorAll(\".line-item-row\")).filter(\n        (r) => !r.classList.contains(\"is-hidden-field\") && !isEmptyLineItemRow(r)\n      );\n      (((_a = group.lineItemConfig) == null ? void 0 : _a.fields) || []).forEach((field) => {\n        (field.validationRules || []).forEach((rule) => {\n          rows.forEach((row) => {\n            const whenName = group.id + \"__\" + rule.when.fieldId;\n            const thenName = group.id + \"__\" + rule.then.fieldId;\n            let whenVal = getRowValue(row, whenName);\n            if (whenVal === \"\" || Array.isArray(whenVal) && whenVal.length === 0) {\n              whenVal = getValue(formEl, rule.when.fieldId);\n            }\n            if (!matchesWhen(whenVal, rule.when)) return;\n            if (isFieldHidden(rule.then.fieldId, formEl, row)) return;\n            const targetVal = getRowValue(row, thenName);\n            const msg = checkRule(targetVal, rule.then, language, rule.message);\n            if (msg) {\n              errors.push({\n                fieldId: rule.then.fieldId,\n                message: msg,\n                scope: \"line\",\n                rowId: row.dataset.rowId\n              });\n            }\n          });\n        });\n      });\n    });\n    if (errors.length && typeof console !== \"undefined\" && console.warn) {\n      console.warn(\"[validation] errors\", errors);\n    }\n    return { errors };\n  }\n  function resolveFieldElement(err, formEl) {\n    if (err.scope === \"line\" && err.rowId) {\n      const row = formEl.querySelector('[data-row-id=\"' + err.rowId + '\"]');\n      if (row) {\n        return findFieldElement(err.fieldId, row, row);\n      }\n    }\n    return findFieldElement(err.fieldId, formEl);\n  }\n\n  // src/web/legacy/payload.ts\n  function syncLineItemPayload(definition, formEl) {\n    definition.questions.forEach((q) => {\n      if (q.type !== \"LINE_ITEM_GROUP\") return;\n      const container = formEl.querySelector('[data-line-item=\"' + q.id + '\"]');\n      const hidden = formEl.querySelector('[name=\"' + q.id + '_json\"]');\n      if (!container || !hidden) return;\n      const rows = Array.from(container.querySelectorAll(\".line-item-row\")).filter(\n        (r) => !r.classList.contains(\"is-hidden-field\") && !isEmptyLineItemRow(r)\n      );\n      const data = rows.map((row) => {\n        var _a;\n        const result = {};\n        (((_a = q.lineItemConfig) == null ? void 0 : _a.fields) || []).forEach((field) => {\n          const name = q.id + \"__\" + field.id;\n          const inputs = row.querySelectorAll('[name=\"' + name + '\"]');\n          if (!inputs || inputs.length === 0) return;\n          if (inputs[0].type === \"checkbox\") {\n            const selected = Array.from(inputs).filter((i) => i.checked).map((i) => i.value);\n            result[field.id] = selected.join(\", \");\n          } else {\n            result[field.id] = inputs[0].value;\n          }\n        });\n        return result;\n      });\n      hidden.value = JSON.stringify(data);\n    });\n  }\n  function buildPayloadFromForm(formEl) {\n    const fd = new FormData(formEl);\n    const payload = {};\n    const fileReads = [];\n    const addValue = (key2, val) => {\n      if (payload[key2] === void 0) {\n        payload[key2] = val;\n      } else if (Array.isArray(payload[key2])) {\n        payload[key2].push(val);\n      } else {\n        payload[key2] = [payload[key2], val];\n      }\n    };\n    fd.forEach((val, key2) => {\n      if (val instanceof File) {\n        if (!val || !val.name && val.size === 0) return;\n        const reader = new FileReader();\n        const p = new Promise((resolve) => {\n          reader.onload = () => {\n            addValue(key2, {\n              name: val.name || \"upload\",\n              data: reader.result,\n              type: val.type || \"application/octet-stream\"\n            });\n            resolve();\n          };\n          reader.onerror = () => resolve();\n        });\n        reader.readAsDataURL(val);\n        fileReads.push(p);\n      } else {\n        addValue(key2, val);\n      }\n    });\n    return Promise.all(fileReads).then(() => payload);\n  }\n\n  // src/web/lineItems/index.ts\n  function isEmptyRow(rowValues) {\n    const entries = Object.values(rowValues);\n    return entries.every((val) => {\n      if (val === null || val === void 0) return true;\n      if (typeof val === \"string\") return val.trim() === \"\";\n      if (Array.isArray(val)) return val.length === 0;\n      return false;\n    });\n  }\n  function computeTotals(input, language) {\n    const { config, rows } = input;\n    if (!config.totals || !config.totals.length) return [];\n    return config.totals.map((totalCfg) => {\n      let total = 0;\n      if (totalCfg.type === \"count\") {\n        total = rows.filter((r) => !isEmptyRow(r.values)).length;\n      } else if (totalCfg.type === \"sum\") {\n        const fieldKey = totalCfg.fieldId;\n        if (fieldKey) {\n          rows.forEach((row) => {\n            const val = row.values[fieldKey];\n            const parsed = Array.isArray(val) ? Number(val[0]) : Number(val);\n            if (!isNaN(parsed)) total += parsed;\n          });\n        } else {\n          total = 0;\n        }\n      }\n      const label = resolveLocalizedString(\n        totalCfg.label,\n        language,\n        totalCfg.type === \"count\" ? \"Total\" : totalCfg.fieldId || \"Total\"\n      );\n      return {\n        key: totalCfg.fieldId || totalCfg.type,\n        label,\n        value: Number.isFinite(total) ? total : 0,\n        decimalPlaces: totalCfg.decimalPlaces\n      };\n    });\n  }\n\n  // src/web/effects/selectionEffects.ts\n  function applies(effect, value) {\n    if (!effect.triggerValues || effect.triggerValues.length === 0) return true;\n    const vals = Array.isArray(value) ? value : value ? [value] : [];\n    return vals.some((v) => effect.triggerValues.includes(v));\n  }\n  function handleSelectionEffects(definition, question, value, _language, ctx) {\n    if (!(question == null ? void 0 : question.selectionEffects) || !question.selectionEffects.length) return;\n    question.selectionEffects.forEach((effect) => {\n      if (effect.type === \"addLineItems\" && applies(effect, value)) {\n        ctx.addLineItemRow(effect.groupId, effect.preset);\n      }\n    });\n  }\n\n  // src/web/data/dataSources.ts\n  var cache = /* @__PURE__ */ new Map();\n  function key(id, lang) {\n    return `${id || \"default\"}::${(lang || \"EN\").toString().toUpperCase()}`;\n  }\n  async function fetchDataSource(config, language) {\n    var _a;\n    const cacheKey = key(config.id, language);\n    if (cache.has(cacheKey)) return cache.get(cacheKey);\n    const scriptRun = (_a = google == null ? void 0 : google.script) == null ? void 0 : _a.run;\n    if (!scriptRun) {\n      return null;\n    }\n    return new Promise((resolve) => {\n      var _a2, _b;\n      try {\n        (_b = (_a2 = scriptRun.withSuccessHandler((res) => {\n          cache.set(cacheKey, res);\n          resolve(res);\n        }).withFailureHandler(() => resolve(null))).fetchDataSource) == null ? void 0 : _b.call(_a2, config, language, config.projection, config.limit, void 0);\n      } catch (_) {\n        resolve(null);\n      }\n    });\n  }\n  async function resolveQuestionOptionsFromSource(question, language) {\n    if (!question.dataSource || question.type !== \"CHOICE\") return null;\n    const res = await fetchDataSource(question.dataSource, language);\n    if (!res) return null;\n    const items = Array.isArray(res.items) ? res.items : Array.isArray(res) ? res : [];\n    if (!items.length) return null;\n    const mapping = question.dataSource.mapping || {};\n    const valueKey = mapping.value || mapping.id;\n    if (typeof items[0] === \"object\" && !Array.isArray(items[0])) {\n      const keys = Object.keys(items[0]);\n      if (!keys.length) return null;\n      const resolvedKey = valueKey || keys[0];\n      return items.map((row) => row[resolvedKey]).filter(Boolean).map((v) => v.toString());\n    }\n    return items.map((v) => v != null ? v.toString() : \"\").filter(Boolean);\n  }\n\n  // src/web/legacy/dataSources.ts\n  function buildOptionEl(value, labels, langKey) {\n    const opt = document.createElement(\"option\");\n    opt.value = value;\n    opt.dataset.enLabel = labels.en || value;\n    opt.dataset.frLabel = labels.fr || value;\n    opt.dataset.nlLabel = labels.nl || value;\n    const localized = labels[langKey] || labels.en || value;\n    opt.textContent = localized;\n    return opt;\n  }\n  function writeOptionsToSelect(select, options, labelsMap) {\n    select.innerHTML = \"\";\n    const emptyOpt = document.createElement(\"option\");\n    emptyOpt.value = \"\";\n    emptyOpt.textContent = \"\";\n    select.appendChild(emptyOpt);\n    const langKey = (labelsMap.__lang || \"en\").toString().toLowerCase();\n    options.forEach((value, idx) => {\n      var _a, _b, _c;\n      const labels = {\n        en: ((_a = labelsMap.en) == null ? void 0 : _a[idx]) || value,\n        fr: ((_b = labelsMap.fr) == null ? void 0 : _b[idx]) || value,\n        nl: ((_c = labelsMap.nl) == null ? void 0 : _c[idx]) || value\n      };\n      select.appendChild(buildOptionEl(value, labels, langKey));\n    });\n    select.dataset.originalOptions = JSON.stringify({ en: labelsMap.en || options, fr: labelsMap.fr || options, nl: labelsMap.nl || options });\n  }\n  function writeOptionsToCheckbox(wrapper, name, options, labelsMap) {\n    wrapper.innerHTML = \"\";\n    const langKey = (labelsMap.__lang || \"en\").toString().toLowerCase();\n    options.forEach((value, idx) => {\n      var _a, _b, _c;\n      const labels = {\n        en: ((_a = labelsMap.en) == null ? void 0 : _a[idx]) || value,\n        fr: ((_b = labelsMap.fr) == null ? void 0 : _b[idx]) || value,\n        nl: ((_c = labelsMap.nl) == null ? void 0 : _c[idx]) || value\n      };\n      const id = name + \"_\" + idx + \"_\" + Math.random().toString(16).slice(2);\n      const label = document.createElement(\"label\");\n      label.className = \"inline\";\n      label.style.fontWeight = \"400\";\n      label.htmlFor = id;\n      label.dataset.enLabel = labels.en || value;\n      label.dataset.frLabel = labels.fr || value;\n      label.dataset.nlLabel = labels.nl || value;\n      const cb = document.createElement(\"input\");\n      cb.type = \"checkbox\";\n      cb.name = name;\n      cb.id = id;\n      cb.value = value;\n      const span = document.createElement(\"span\");\n      span.className = \"option-label\";\n      span.textContent = labels[langKey] || labels.en || value;\n      label.appendChild(cb);\n      label.appendChild(span);\n      wrapper.appendChild(label);\n    });\n    wrapper.dataset.originalOptions = JSON.stringify({ en: labelsMap.en || options, fr: labelsMap.fr || options, nl: labelsMap.nl || options });\n  }\n  async function hydrateQuestionOptions(question, language, formEl) {\n    const options = await resolveQuestionOptionsFromSource(question, language);\n    if (!options || !options.length) return;\n    const langKey = (language || \"en\").toString().toLowerCase();\n    const labelsMap = {\n      en: options,\n      fr: options,\n      nl: options,\n      __lang: langKey\n    };\n    if (question.type === \"CHOICE\") {\n      const select = formEl.querySelector('[name=\"' + question.id + '\"]');\n      if (select) writeOptionsToSelect(select, options, labelsMap);\n    } else if (question.type === \"CHECKBOX\") {\n      const wrapper = formEl.querySelector('[data-field-name=\"' + question.id + '\"]') || formEl.querySelector('[name=\"' + question.id + '\"]');\n      if (wrapper) writeOptionsToCheckbox(wrapper, question.id, options, labelsMap);\n    }\n  }\n  async function hydrateDataSources(definition, language, formEl) {\n    const tasks = [];\n    definition.questions.forEach((q) => {\n      if (q.dataSource && (q.type === \"CHOICE\" || q.type === \"CHECKBOX\")) {\n        tasks.push(hydrateQuestionOptions(q, language, formEl));\n      }\n    });\n    await Promise.all(tasks);\n  }\n\n  // src/web/legacy/lineItems.ts\n  function addLineItemRowFromBundle(group, formEl, presetValues = {}) {\n    var _a;\n    if (group.type !== \"LINE_ITEM_GROUP\") return;\n    const container = formEl.querySelector('[data-line-item=\"' + group.id + '\"]');\n    if (!container) return;\n    const rowsWrapper = container.querySelector(\".line-item-rows\") || container;\n    const row = document.createElement(\"div\");\n    row.className = \"line-item-row\";\n    row.dataset.rowId = group.id + \"_\" + Math.random().toString(16).slice(2);\n    row.dataset.groupId = group.id;\n    (((_a = group.lineItemConfig) == null ? void 0 : _a.fields) || []).forEach((field) => {\n      const cell = document.createElement(\"div\");\n      cell.dataset.fieldId = field.id;\n      cell.dataset.groupId = group.id;\n      const lbl = document.createElement(\"label\");\n      lbl.dataset.enLabel = field.labelEn || \"\";\n      lbl.dataset.frLabel = field.labelFr || \"\";\n      lbl.dataset.nlLabel = field.labelNl || \"\";\n      lbl.textContent = \"\";\n      if (field.required) {\n        const star = document.createElement(\"span\");\n        star.className = \"required-star\";\n        star.textContent = \"*\";\n        lbl.appendChild(star);\n      }\n      const labelText = document.createElement(\"span\");\n      labelText.dataset.labelText = \"true\";\n      labelText.textContent = field.labelEn || \"\";\n      lbl.appendChild(labelText);\n      cell.appendChild(lbl);\n      let input;\n      if (field.type === \"CHOICE\") {\n        const select = document.createElement(\"select\");\n        select.dataset.fieldId = field.id;\n        select.dataset.labelEn = (field.labelEn || \"\").toLowerCase();\n        const emptyOpt = document.createElement(\"option\");\n        emptyOpt.value = \"\";\n        emptyOpt.textContent = \"\";\n        select.appendChild(emptyOpt);\n        (field.options || []).forEach((opt, idx) => {\n          var _a2, _b;\n          const option = document.createElement(\"option\");\n          option.value = opt;\n          option.dataset.enLabel = opt;\n          option.dataset.frLabel = ((_a2 = field.optionsFr) == null ? void 0 : _a2[idx]) || opt;\n          option.dataset.nlLabel = ((_b = field.optionsNl) == null ? void 0 : _b[idx]) || opt;\n          option.textContent = opt;\n          select.appendChild(option);\n        });\n        select.dataset.originalOptions = JSON.stringify({ en: field.options || [], fr: field.optionsFr || [], nl: field.optionsNl || [] });\n        if (field.optionFilter) select.dataset.dependsOn = field.optionFilter.dependsOn;\n        input = select;\n      } else if (field.type === \"CHECKBOX\") {\n        const wrap = document.createElement(\"div\");\n        wrap.dataset.fieldName = group.id + \"__\" + field.id;\n        wrap.dataset.fieldId = field.id;\n        wrap.dataset.labelEn = (field.labelEn || \"\").toLowerCase();\n        (field.options || []).forEach((opt, idx) => {\n          var _a2, _b;\n          const checkbox = document.createElement(\"label\");\n          checkbox.className = \"inline\";\n          checkbox.style.fontWeight = \"400\";\n          checkbox.dataset.enLabel = opt;\n          checkbox.dataset.frLabel = ((_a2 = field.optionsFr) == null ? void 0 : _a2[idx]) || opt;\n          checkbox.dataset.nlLabel = ((_b = field.optionsNl) == null ? void 0 : _b[idx]) || opt;\n          const cb = document.createElement(\"input\");\n          cb.type = \"checkbox\";\n          cb.value = opt;\n          cb.name = group.id + \"__\" + field.id;\n          const span = document.createElement(\"span\");\n          span.className = \"option-label\";\n          span.textContent = opt;\n          checkbox.appendChild(cb);\n          checkbox.appendChild(span);\n          wrap.appendChild(checkbox);\n        });\n        wrap.dataset.originalOptions = JSON.stringify({ en: field.options || [], fr: field.optionsFr || [], nl: field.optionsNl || [] });\n        if (field.optionFilter) wrap.dataset.dependsOn = field.optionFilter.dependsOn;\n        input = wrap;\n      } else {\n        const inp = document.createElement(\"input\");\n        inp.type = field.type === \"NUMBER\" ? \"number\" : \"text\";\n        if (field.type === \"NUMBER\") inp.step = \"any\";\n        inp.name = group.id + \"__\" + field.id;\n        input = inp;\n      }\n      if (input && input.tagName !== \"DIV\") {\n        const cast = input;\n        cast.required = !!field.required;\n        cast.name = group.id + \"__\" + field.id;\n        cast.dataset.fieldId = field.id;\n        cast.dataset.labelEn = (field.labelEn || \"\").toLowerCase();\n        if (presetValues[field.id] !== void 0 && \"value\" in cast) {\n          cast.value = presetValues[field.id];\n        }\n      }\n      cell.appendChild(input);\n      row.appendChild(cell);\n    });\n    const actions = document.createElement(\"div\");\n    const removeBtn = document.createElement(\"button\");\n    removeBtn.type = \"button\";\n    removeBtn.className = \"secondary\";\n    removeBtn.textContent = \"Remove\";\n    removeBtn.addEventListener(\"click\", () => {\n      if (row.parentElement) row.parentElement.removeChild(row);\n      computeLineItemTotals(group, formEl);\n    });\n    actions.appendChild(removeBtn);\n    row.appendChild(actions);\n    row.addEventListener(\"input\", () => computeLineItemTotals(group, formEl));\n    row.addEventListener(\"change\", () => computeLineItemTotals(group, formEl));\n    rowsWrapper.appendChild(row);\n    applyFilters({ definition: { questions: [group] }, language: \"EN\", formEl, scopeRow: row });\n    applyVisibility({ definition: { questions: [group] }, language: \"EN\", formEl });\n    computeLineItemTotals(group, formEl);\n  }\n  function computeLineItemTotals(group, formEl) {\n    var _a, _b;\n    if (group.type !== \"LINE_ITEM_GROUP\" || !((_b = (_a = group.lineItemConfig) == null ? void 0 : _a.totals) == null ? void 0 : _b.length)) return;\n    const container = formEl.querySelector('[data-line-item=\"' + group.id + '\"]');\n    if (!container) return;\n    const holder = container.querySelector(\"[data-line-totals]\");\n    if (!holder) return;\n    const rows = Array.from(container.querySelectorAll(\".line-item-row\")).filter(\n      (r) => !r.classList.contains(\"is-hidden-field\") && !isEmptyLineItemRow(r)\n    );\n    holder.innerHTML = \"\";\n    const rowData = rows.map((row) => {\n      var _a2;\n      const values = {};\n      (((_a2 = group.lineItemConfig) == null ? void 0 : _a2.fields) || []).forEach((field) => {\n        var _a3;\n        const name = group.id + \"__\" + field.id;\n        const val = ((_a3 = row.querySelector('[name=\"' + name + '\"]')) == null ? void 0 : _a3.value) || \"\";\n        values[field.id] = val;\n      });\n      return { id: row.dataset.rowId || \"\", values };\n    });\n    const totals = computeTotals({ config: group.lineItemConfig, rows: rowData }, \"EN\");\n    totals.forEach((t) => {\n      const pill = document.createElement(\"div\");\n      pill.className = \"line-item-total-pill\";\n      pill.textContent = t.label ? t.label + \": \" + t.value : String(t.value);\n      holder.appendChild(pill);\n    });\n  }\n\n  // src/web/views/router.ts\n  function createViewRouter(definition, ctx) {\n    let current = \"form\";\n    const listeners2 = [];\n    function render(view) {\n      var _a, _b, _c;\n      current = view;\n      switch (view) {\n        case \"form\":\n          ctx.renderForm();\n          break;\n        case \"list\":\n          (_a = ctx.renderList) == null ? void 0 : _a.call(ctx);\n          break;\n        case \"summary\":\n          (_b = ctx.renderSummary) == null ? void 0 : _b.call(ctx);\n          break;\n        case \"followup\":\n          (_c = ctx.renderFollowup) == null ? void 0 : _c.call(ctx);\n          break;\n        default:\n          ctx.renderForm();\n      }\n      listeners2.forEach((l) => l(view, current));\n    }\n    return {\n      get current() {\n        return current;\n      },\n      goTo: (view) => render(view),\n      onChange: (listener) => {\n        listeners2.push(listener);\n      }\n    };\n  }\n\n  // src/web/views/listView.ts\n  function renderListView(opts) {\n    const { mount, definition, language, fetchRows, onSelectRow } = opts;\n    mount.innerHTML = \"\";\n    const title = document.createElement(\"h2\");\n    title.textContent = definition.title + \" - List\";\n    mount.appendChild(title);\n    const status = document.createElement(\"div\");\n    status.textContent = \"Loading...\";\n    mount.appendChild(status);\n    if (!fetchRows) {\n      status.textContent = language === \"FR\" ? \"Aucune source de donn\\xE9es.\" : language === \"NL\" ? \"Geen gegevensbron.\" : \"No data source.\";\n      return;\n    }\n    const config = definition.listView;\n    const columns = (config == null ? void 0 : config.columns) && config.columns.length ? config.columns : definition.questions.map((q) => ({ fieldId: q.id, label: q.label }));\n    const table = document.createElement(\"table\");\n    table.style.width = \"100%\";\n    table.style.borderCollapse = \"collapse\";\n    const header = document.createElement(\"tr\");\n    columns.forEach((col) => {\n      const th = document.createElement(\"th\");\n      th.style.textAlign = \"left\";\n      th.style.borderBottom = \"1px solid #e5e7eb\";\n      th.style.padding = \"6px\";\n      th.textContent = resolveLabel(col.label, col.fieldId, language);\n      header.appendChild(th);\n    });\n    const thMeta = document.createElement(\"th\");\n    thMeta.style.textAlign = \"left\";\n    thMeta.style.borderBottom = \"1px solid #e5e7eb\";\n    thMeta.style.padding = \"6px\";\n    thMeta.textContent = \"Updated\";\n    header.appendChild(thMeta);\n    table.appendChild(header);\n    const pager = document.createElement(\"div\");\n    pager.style.margin = \"8px 0\";\n    let nextToken;\n    const renderPage = (token) => {\n      status.textContent = language === \"FR\" ? \"Chargement...\" : language === \"NL\" ? \"Bezig met laden...\" : \"Loading...\";\n      fetchRows(token).then((res) => {\n        status.textContent = \"\";\n        table.querySelectorAll(\"tr:not(:first-child)\").forEach((row) => row.remove());\n        (res.items || []).forEach((row) => {\n          const tr = document.createElement(\"tr\");\n          tr.style.cursor = onSelectRow ? \"pointer\" : \"default\";\n          columns.forEach((col) => {\n            const td = document.createElement(\"td\");\n            td.style.padding = \"6px\";\n            td.style.borderBottom = \"1px solid #f1f5f9\";\n            td.textContent = valueToString(row[col.fieldId]);\n            tr.appendChild(td);\n          });\n          const meta = document.createElement(\"td\");\n          meta.style.padding = \"6px\";\n          meta.style.borderBottom = \"1px solid #f1f5f9\";\n          meta.textContent = row.updatedAt || row.createdAt || \"\";\n          tr.appendChild(meta);\n          if (onSelectRow) {\n            tr.addEventListener(\"click\", () => onSelectRow(row));\n          }\n          table.appendChild(tr);\n        });\n        nextToken = res.nextPageToken;\n        pager.innerHTML = \"\";\n        if (nextToken) {\n          const btn = document.createElement(\"button\");\n          btn.textContent = language === \"FR\" ? \"Suivant\" : language === \"NL\" ? \"Volgende\" : \"Next\";\n          btn.addEventListener(\"click\", () => renderPage(nextToken));\n          pager.appendChild(btn);\n        } else if (!res.items || !res.items.length) {\n          status.textContent = language === \"FR\" ? \"Aucune donn\\xE9e.\" : language === \"NL\" ? \"Geen gegevens.\" : \"No data.\";\n        }\n      }).catch(() => {\n        status.textContent = language === \"FR\" ? \"Erreur de chargement.\" : language === \"NL\" ? \"Fout bij laden.\" : \"Failed to load.\";\n      });\n    };\n    mount.appendChild(table);\n    mount.appendChild(pager);\n    renderPage();\n  }\n  function resolveLabel(label, fallback, language) {\n    if (!label) return fallback;\n    if (typeof label === \"string\") return label;\n    const key2 = (language || \"en\").toString().toLowerCase();\n    return label[key2] || label.en || fallback;\n  }\n  function valueToString(val) {\n    if (val === null || val === void 0) return \"\";\n    if (Array.isArray(val)) return val.join(\", \");\n    if (val instanceof Date) return val.toISOString();\n    return val.toString();\n  }\n\n  // src/web/views/summaryView.ts\n  function renderSummaryView(opts) {\n    const { mount, definition, language, payload } = opts;\n    mount.innerHTML = \"\";\n    const title = document.createElement(\"h2\");\n    title.textContent = language === \"FR\" ? \"R\\xE9sum\\xE9\" : language === \"NL\" ? \"Samenvatting\" : \"Summary\";\n    mount.appendChild(title);\n    definition.questions.forEach((q) => {\n      const block = document.createElement(\"div\");\n      block.style.padding = \"8px 0\";\n      const label = document.createElement(\"div\");\n      label.style.fontWeight = \"800\";\n      label.textContent = q.label.en || q.id;\n      const value = document.createElement(\"div\");\n      const val = payload[q.id];\n      value.textContent = Array.isArray(val) ? val.join(\", \") : val || \"\";\n      block.appendChild(label);\n      block.appendChild(value);\n      mount.appendChild(block);\n    });\n  }\n\n  // src/web/views/followupView.ts\n  function renderFollowupView(opts) {\n    const { mount, language, actions = [] } = opts;\n    mount.innerHTML = \"\";\n    const title = document.createElement(\"h2\");\n    title.textContent = language === \"FR\" ? \"Suivi\" : language === \"NL\" ? \"Vervolg\" : \"Follow-up\";\n    mount.appendChild(title);\n    if (!actions.length) {\n      const empty = document.createElement(\"div\");\n      empty.textContent = language === \"FR\" ? \"Aucune action disponible.\" : language === \"NL\" ? \"Geen acties beschikbaar.\" : \"No follow-up actions available.\";\n      mount.appendChild(empty);\n      return;\n    }\n    actions.forEach((action) => {\n      const btn = document.createElement(action.href ? \"a\" : \"button\");\n      btn.textContent = action.label;\n      btn.style = \"display:inline-block;margin:4px 6px;padding:10px 14px;border:1px solid #e2e8f0;border-radius:10px;text-decoration:none;color:#0f172a;background:#fff;\";\n      if (action.href) {\n        btn.href = action.href;\n        btn.target = \"_blank\";\n      } else if (action.onClick) {\n        btn.addEventListener(\"click\", action.onClick);\n      }\n      mount.appendChild(btn);\n    });\n  }\n\n  // src/web/data/submissions.ts\n  async function fetchSubmissionsPage(opts) {\n    const { formKey, projection, pageSize = 10, pageToken } = opts;\n    const runner = typeof google !== \"undefined\" && google.script && google.script.run ? google.script.run : null;\n    if (!runner || typeof runner.withSuccessHandler !== \"function\") {\n      return { items: [], totalCount: 0, nextPageToken: void 0 };\n    }\n    return new Promise((resolve) => {\n      try {\n        runner.withSuccessHandler((res) => resolve(res || { items: [], totalCount: 0 })).withFailureHandler(() => resolve({ items: [], totalCount: 0 })).fetchSubmissions(formKey || \"\", projection || void 0, pageSize, pageToken);\n      } catch (_) {\n        resolve({ items: [], totalCount: 0 });\n      }\n    });\n  }\n\n  // src/web/data/submit.ts\n  async function submitWithDedup(payload) {\n    var _a;\n    const runner = (_a = google == null ? void 0 : google.script) == null ? void 0 : _a.run;\n    if (!runner || typeof runner.withSuccessHandler !== \"function\") {\n      return { success: false, message: \"Submission unavailable offline.\" };\n    }\n    return new Promise((resolve) => {\n      var _a2, _b;\n      try {\n        (_b = (_a2 = runner.withSuccessHandler((res) => resolve(res || { success: false, message: \"Unknown response\" })).withFailureHandler((err) => resolve({ success: false, message: err && err.message || \"Submit failed\" }))).saveSubmissionWithId) == null ? void 0 : _b.call(_a2, payload);\n      } catch (err) {\n        resolve({ success: false, message: (err == null ? void 0 : err.message) || \"Submit failed\" });\n      }\n    });\n  }\n\n  // src/web/main.ts\n  function bootstrapWebForm(definition, formKey, opts) {\n    const initialLang = definition.languages && definition.languages[0] || \"EN\";\n    setState({ language: initialLang });\n    if (opts == null ? void 0 : opts.onReady) opts.onReady(definition, formKey);\n    if (opts == null ? void 0 : opts.mountListView) {\n      renderListView({\n        mount: opts.mountListView,\n        definition,\n        language: initialLang,\n        fetchRows: (pageToken) => fetchSubmissionsPage({ formKey, pageToken }),\n        onSelectRow: (row) => {\n          setState({ recordMeta: { id: row.id, createdAt: row.createdAt, updatedAt: row.updatedAt } });\n        }\n      });\n    }\n    if (typeof console !== \"undefined\") {\n      console.info(\"[WebFormApp] bootstrapped\", { formKey, language: initialLang });\n    }\n  }\n  if (typeof window !== \"undefined\") {\n    window.WebFormApp = { ...window.WebFormApp || {}, bootstrapWebForm };\n    window.WebFormApp.updateLanguageLabels = updateLanguageLabels;\n    window.WebFormApp.applyFiltersAndVisibility = (opts) => {\n      const { definition, language, formEl, scopeRow } = opts;\n      applyFilters({ definition, language, formEl, scopeRow });\n      applyVisibility({ definition, language, formEl });\n    };\n    window.WebFormApp.validateFormWithBundle = validateFormWithBundle;\n    window.WebFormApp.resolveFieldElement = resolveFieldElement;\n    window.WebFormApp.computeLineTotals = computeTotals;\n    window.WebFormApp.syncLineItemPayload = syncLineItemPayload;\n    window.WebFormApp.buildPayloadFromForm = buildPayloadFromForm;\n    window.WebFormApp.handleSelectionEffects = handleSelectionEffects;\n    window.WebFormApp.hydrateDataSources = hydrateDataSources;\n    window.WebFormApp.addLineItemRowFromBundle = addLineItemRowFromBundle;\n    window.WebFormApp.computeLineItemTotalsLegacy = computeLineItemTotals;\n    window.WebFormApp.createViewRouter = createViewRouter;\n    window.WebFormApp.renderListView = renderListView;\n    window.WebFormApp.renderSummaryView = renderSummaryView;\n    window.WebFormApp.renderFollowupView = renderFollowupView;\n    window.WebFormApp.fetchSubmissionsPage = fetchSubmissionsPage;\n    window.WebFormApp.submitWithDedup = submitWithDedup;\n  }\n  return __toCommonJS(main_exports);\n})();\n";
