import { handleSelectionEffects } from '../../core';
import { FieldValue, LangCode, LineItemRowState, WebFormDefinition, WebQuestionDefinition } from '../../types';
import { LineItemState } from '../types';
import { applyValueMapsToForm } from './valueMaps';
import {
  ROW_SOURCE_AUTO,
  ROW_SOURCE_KEY,
  buildSubgroupKey,
  parseRowSource,
  parseSubgroupKey,
  resolveSubgroupKey,
  seedSubgroupDefaults
} from './lineItems';

type SelectionEffectOpts = {
  lineItem?: { groupId: string; rowId: string; rowValues: any };
  contextId?: string;
  forceContextReset?: boolean;
};

export const runSelectionEffects = (args: {
  definition: WebFormDefinition;
  question: WebQuestionDefinition;
  value: FieldValue;
  language: LangCode;
  values: Record<string, FieldValue>;
  setValues: (next: Record<string, FieldValue> | ((prev: Record<string, FieldValue>) => Record<string, FieldValue>)) => void;
  setLineItems: (next: LineItemState | ((prev: LineItemState) => LineItemState)) => void;
  logEvent?: (event: string, payload?: Record<string, unknown>) => void;
  opts?: SelectionEffectOpts;
}) => {
  const { definition, question, value, language, values, setValues, setLineItems, logEvent, opts } = args;
  if (!question.selectionEffects || !question.selectionEffects.length) return;

  const resolveTargetGroupKey = (targetGroupId: string, lineItemCtx?: { groupId: string; rowId?: string }): string => {
    if (!lineItemCtx?.groupId || !lineItemCtx?.rowId) return targetGroupId;
    const parentGroup = definition.questions.find(q => q.id === lineItemCtx.groupId);
    const subMatch = parentGroup?.lineItemConfig?.subGroups?.find(sub => {
      const key = resolveSubgroupKey(sub as any);
      return key === targetGroupId;
    });
    if (subMatch) {
      const key = resolveSubgroupKey(subMatch as any) || targetGroupId;
      return buildSubgroupKey(lineItemCtx.groupId, lineItemCtx.rowId, key);
    }
    return targetGroupId;
  };

  handleSelectionEffects(
    definition,
    question,
    value as any,
    language,
    {
      addLineItemRow: (
        groupId: string,
        preset?: Record<string, any>,
        meta?: { effectContextId?: string; auto?: boolean }
      ) => {
        setLineItems(prev => {
          const targetKey = resolveTargetGroupKey(groupId, opts?.lineItem);
          const rows = prev[targetKey] || [];
          // capture section selector value at creation so later selector changes don't rewrite existing rows
          const targetGroup =
            definition.questions.find(q => q.id === targetKey) ||
            definition.questions.find(q => q.id === opts?.lineItem?.groupId);
          const selectorId = targetGroup?.lineItemConfig?.sectionSelector?.id;
          const selectorValue = selectorId && Object.prototype.hasOwnProperty.call(values, selectorId) ? (values as any)[selectorId] : undefined;
          const presetValues: Record<string, FieldValue> = {};
          Object.entries(preset || {}).forEach(([key, raw]) => {
            if (raw === undefined || raw === null) return;
            presetValues[key] = raw as FieldValue;
          });
          if (meta?.auto === true) {
            presetValues[ROW_SOURCE_KEY] = ROW_SOURCE_AUTO;
          }
          if (selectorId && selectorValue !== undefined && selectorValue !== null && presetValues[selectorId] === undefined) {
            presetValues[selectorId] = selectorValue;
          }
          const newRow: LineItemRowState = {
            id: `${targetKey}_${Math.random().toString(16).slice(2)}`,
            values: presetValues,
            parentId: opts?.lineItem?.rowId,
            parentGroupId: opts?.lineItem?.groupId,
            autoGenerated: meta?.auto,
            effectContextId: meta?.effectContextId
          };
          const subgroupInfo = parseSubgroupKey(targetKey);
          let nextLineItems = { ...prev, [targetKey]: [...rows, newRow] };
          if (!subgroupInfo) {
            const parentGroup = definition.questions.find(q => q.id === targetKey);
            if (parentGroup) {
              nextLineItems = seedSubgroupDefaults(nextLineItems, parentGroup, newRow.id);
            }
          }
          const { values: nextValues, lineItems: recomputed } = applyValueMapsToForm(definition, values, nextLineItems, {
            mode: 'change'
          });
          setValues(nextValues);
          return recomputed;
        });
      },
      updateAutoLineItems: (
        groupId: string,
        presets: Array<Record<string, string | number>>,
        meta: { effectContextId: string; numericTargets: string[]; keyFields?: string[] }
      ) => {
        setLineItems(prev => {
          const targetKey = resolveTargetGroupKey(groupId, opts?.lineItem);
          const rows = prev[targetKey] || [];
          const keyFields = (meta.keyFields || []).map(k => k.toString());
          const buildKey = (obj: Record<string, any>): string => {
            if (!keyFields.length) return '';
            return keyFields
              .map(fid => {
                const raw = obj ? (obj as any)[fid] : undefined;
                if (raw === undefined || raw === null) return '';
                if (Array.isArray(raw)) return (raw[0] ?? '').toString().trim();
                return raw.toString().trim();
              })
              .join('||');
          };

          const nextAutoKeys = new Set(keyFields.length ? presets.map(p => buildKey(p as any)).filter(Boolean) : []);

          const keepRows = rows.filter(r => {
            // Keep rows from other effect contexts.
            if (r.effectContextId && r.effectContextId !== meta.effectContextId) return true;

            const source = parseRowSource((r.values as any)?.[ROW_SOURCE_KEY]);
            // Always keep explicit manual rows.
            if (source === 'manual') return true;

            // Drop explicit/known auto rows for this context.
            if ((source === 'auto' || r.autoGenerated) && r.effectContextId === meta.effectContextId) return false;

            // Legacy/unmarked: if it matches a new auto key, treat it as an old auto row and replace it.
            if (keyFields.length && r.effectContextId === meta.effectContextId) {
              const key = buildKey(r.values as any);
              if (key && nextAutoKeys.has(key)) return false;
            }
            return true;
          });

          // Rebuild auto rows for this context from scratch so recipe changes fully replace them
          const rebuiltAuto: LineItemRowState[] = presets.map(preset => {
            const values: Record<string, FieldValue> = { ...preset };
            meta.numericTargets.forEach(fid => {
              if ((preset as any)[fid] !== undefined) {
                values[fid] = (preset as any)[fid] as FieldValue;
              }
            });
            values[ROW_SOURCE_KEY] = ROW_SOURCE_AUTO;
            return {
              id: `${targetKey}_${Math.random().toString(16).slice(2)}`,
              values,
              parentId: opts?.lineItem?.rowId,
              parentGroupId: opts?.lineItem?.groupId,
              autoGenerated: true,
              effectContextId: meta.effectContextId
            };
          });

          const next: LineItemState = { ...prev, [targetKey]: [...keepRows, ...rebuiltAuto] };
          const { values: nextValues, lineItems: recomputed } = applyValueMapsToForm(definition, values, next, {
            mode: 'change'
          });
          setValues(nextValues);
          return recomputed;
        });
      },
      clearLineItems: (groupId: string, contextId?: string) => {
        setLineItems(prev => {
          const targetKey = resolveTargetGroupKey(groupId, opts?.lineItem);
          const rows = prev[targetKey] || [];
          const remaining = contextId
            ? rows.filter(r => !(r.autoGenerated && r.effectContextId === contextId))
            : rows.filter(r => !r.autoGenerated);
          const removedIds = new Set(rows.filter(r => !remaining.includes(r)).map(r => r.id));
          const next: LineItemState = { ...prev, [targetKey]: remaining };
          const subgroupInfo = parseSubgroupKey(targetKey);
          if (!subgroupInfo) {
            Object.keys(next).forEach(key => {
              const parsed = parseSubgroupKey(key);
              if (parsed?.parentGroupId === targetKey && removedIds.has(parsed.parentRowId)) {
                delete (next as any)[key];
              }
            });
          }
          const { values: nextValues, lineItems: recomputed } = applyValueMapsToForm(definition, values, next, {
            mode: 'change'
          });
          setValues(nextValues);
          return recomputed;
        });
        logEvent?.('lineItems.cleared', { groupId });
      }
    },
    opts ? { ...opts, topValues: values } : { topValues: values }
  );
};



